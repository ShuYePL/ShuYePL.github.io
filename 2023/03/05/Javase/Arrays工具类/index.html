<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Arrays工具类 | 番薯日记</title>
  <meta name="keywords" content=" Javase ">
  <meta name="description" content="Arrays工具类 | 番薯日记">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta property="og:type" content="website">
<meta property="og:title" content="番薯日记">
<meta property="og:url" content="http://example.com/archives/index.html">
<meta property="og:site_name" content="番薯日记">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="ShuYePL">
<meta name="twitter:card" content="summary">


<link rel="icon" href="/img/avatar1.jpg">

<link href="/css/style.css?v=1.1.0" rel="stylesheet">

<link href="/css/hl_theme/atom-dark.css?v=1.1.0" rel="stylesheet">

<link href="//cdn.jsdelivr.net/npm/animate.css@4.1.0/animate.min.css" rel="stylesheet">

<script src="//cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<script src="/js/titleTip.js?v=1.1.0" ></script>

<script src="//cdn.jsdelivr.net/npm/highlightjs@9.16.2/highlight.pack.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>

<script src="//cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script>



<script src="//cdn.jsdelivr.net/npm/jquery.cookie@1.4.1/jquery.cookie.min.js" ></script>

<script src="/js/iconfont.js?v=1.1.0" ></script>

<meta name="generator" content="Hexo 5.4.0"></head>
<div style="display: none">
  <input class="theme_disqus_on" value="false">
  <input class="theme_preload_comment" value="">
  <input class="theme_blog_path" value="">
  <input id="theme_shortcut" value="true" />
  <input id="theme_highlight_on" value="true" />
  <input id="theme_code_copy" value="true" />
</div>



<body>
<aside class="nav">
    <div class="nav-left">
        <a href="/"
   class="avatar_target">
    <img class="avatar"
         src="/img/avatar1.jpg"/>
</a>
<div class="author">
    <span>ShuYePL</span>
</div>

<div class="icon">
    
        
            <a title="rss"
               href="/atom.xml"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-rss"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="github"
               href="https://github.com/yelog"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-github"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="facebook"
               href="https://www.facebook.com/faker.tops"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-facebook"></use>
                    </svg>
                
            </a>
        
    
        
    
        
    
        
            <a title="instagram"
               href="https://www.facebook.com/faker.tops"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-instagram"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="reddit"
               href="https://www.reddit.com/user/yelog/"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-reddit"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="weibo"
               href="http://weibo.com/u/2307534817"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-weibo"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="jianshu"
               href="https://www.jianshu.com/u/ff56736de7cf"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-jianshu"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="zhihu"
               href="https://www.zhihu.com/people/jaytp/activities"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-zhihu"></use>
                    </svg>
                
            </a>
        
    
        
    
        
            <a title="oschina"
               href="https://my.oschina.net/yelog"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-oschina"></use>
                    </svg>
                
            </a>
        
    
        
    
        
            <a title="email"
               href="mailto:jaytp@qq.com"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-email"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="qq"
               href="http://wpa.qq.com/msgrd?v=3&uin=3548768596&site=qq&menu=yes"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-qq"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="kugou"
               href="https://www.kugou.com/"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-kugou"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="neteasemusic"
               href="https://music.163.com/#/user/home?id=88151013"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-neteasemusic"></use>
                    </svg>
                
            </a>
        
    
</div>




<ul>
    <li>
        <div class="all active" data-rel="All">All
            
                <small>(77)</small>
            
        </div>
    </li>
    
        
            
                <li>
                    <div data-rel="个人博客">
                        
                        个人博客
                        <small>(11)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="力扣刷题">
                        
                        力扣刷题
                        <small>(1)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="esp32">
                        
                        esp32
                        <small>(1)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="Git">
                        
                        Git
                        <small>(2)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="IDEA">
                        
                        IDEA
                        <small>(5)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="Javase">
                        
                        Javase
                        <small>(7)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="JavaWeb">
                        
                        JavaWeb
                        <small>(20)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="Linux">
                        
                        Linux
                        <small>(1)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="mysql 与 JDBC">
                        
                        mysql 与 JDBC
                        <small>(1)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="mysql数据库与JDBC">
                        
                        mysql数据库与JDBC
                        <small>(1)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="springmvc">
                        
                        springmvc
                        <small>(4)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="vscode">
                        
                        vscode
                        <small>(1)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="Windows 系统设置">
                        
                        Windows 系统设置
                        <small>(1)</small>
                        
                    </div>
                    
                </li>
            
        
    
</ul>
<div class="left-bottom">
    <div class="menus">
        
            
            
            
    </div>
    <div>
        
            <a class="about  hasFriend  site_url"
               
               href="/about">About</a>
        
        <a style="width: 50%"
                
                                           class="friends">Friends</a>
        
    </div>
</div>
<input type="hidden" id="yelog_site_posts_number" value="77">

<div style="display: none">
    <span id="busuanzi_value_site_uv"></span>
    <span id="busuanzi_value_site_pv"></span>
</div>

    </div>
    <div class="nav-right">
        <div class="friends-area">
    <div class="friends-title">
        Links
        <i class="iconfont icon-left"></i>
    </div>
    <div class="friends-content">
        <ul>
            
            <li><a target="_blank" href="http://yelog.org/">叶落阁</a></li>
            
        </ul>
    </div>
</div>
        <div class="title-list">
    <div class="right-top">
        <div id="default-panel">
            <i class="iconfont icon-search" data-title="搜索 快捷键 i"></i>
            <div class="right-title">All</div>
            <i class="iconfont icon-file-tree" data-title="切换到大纲视图 快捷键 w"></i>
        </div>
        <div id="search-panel">
            <i class="iconfont icon-left" data-title="返回"></i>
            <input id="local-search-input" autocomplete="off"/>
            <label class="border-line" for="input"></label>
            <i class="iconfont icon-case-sensitive" data-title="大小写敏感"></i>
            <i class="iconfont icon-tag" data-title="标签"></i>
        </div>
        <div id="outline-panel" style="display: none">
            <div class="right-title">大纲</div>
            <i class="iconfont icon-list" data-title="切换到文章列表"></i>
        </div>
    </div>

    <div class="tags-list">
    <input id="tag-search" />
    <div class="tag-wrapper">
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>笔记</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>个人博客</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>计基</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>加速器</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>算法</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>esp32</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Git</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>IDEA</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Java</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Java 数据结构与算法</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Javase</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>JavaWeb</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Linux</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>mysql 与 JDBC</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>mysql数据库与JDBC</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>springmvc</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>vscode</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Windows 系统设置</a>
            </li>
        
    </div>

</div>

    
    <nav id="title-list-nav">
        
        
        <a  class="All "
           href="/2023/03/05/Javase/Arrays%E5%B7%A5%E5%85%B7%E7%B1%BB/"
           data-tag="Javase"
           data-author="" >
            <span class="post-title" title="Arrays工具类">Arrays工具类</span>
            <span class="post-date" title="2023-03-05 11:23:00">2023/03/05</span>
        </a>
        
        
        <a  class="All "
           href="/2023/03/05/ASCII/"
           data-tag="计基"
           data-author="" >
            <span class="post-title" title="ASCII">ASCII</span>
            <span class="post-date" title="2023-03-05 10:13:00">2023/03/05</span>
        </a>
        
        
        <a  class="All "
           href="/2023/03/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/"
           data-tag="Java 数据结构与算法"
           data-author="" >
            <span class="post-title" title="排序总结">排序总结</span>
            <span class="post-date" title="2023-03-04 21:51:00">2023/03/04</span>
        </a>
        
        
        <a  class="All "
           href="/2023/03/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84%E5%92%8C%E9%98%9F%E5%88%97/"
           data-tag="Java 数据结构与算法"
           data-author="" >
            <span class="post-title" title="排序总结">排序总结</span>
            <span class="post-date" title="2023-03-04 19:41:00">2023/03/04</span>
        </a>
        
        
        <a  class="All "
           href="/2022/11/19/IDEA/Cannot%20run%20program%20DJava1.8%E3%80%82%E3%80%82%E3%80%82%E7%B3%BB%E7%BB%9F%E6%89%BE%E4%B8%8D%E5%88%B0%E6%8C%87%E5%AE%9A%E7%9A%84%E6%96%87%E4%BB%B6/"
           data-tag=""
           data-author="" >
            <span class="post-title" title=""></span>
            <span class="post-date" title="2022-11-19 16:21:19">2022/11/19</span>
        </a>
        
        
        <a  class="All "
           href="/2022/11/12/Ubuntu%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%B8%80%E4%BA%9B%E6%93%8D%E4%BD%9C%E8%AE%B0%E5%BD%95/"
           data-tag=""
           data-author="" >
            <span class="post-title" title=""></span>
            <span class="post-date" title="2022-11-12 00:03:56">2022/11/12</span>
        </a>
        
        
        <a  class="All "
           href="/2022/11/03/mybatis%E6%8A%A5%E9%94%99/"
           data-tag=""
           data-author="" >
            <span class="post-title" title=""></span>
            <span class="post-date" title="2022-11-03 22:38:43">2022/11/03</span>
        </a>
        
        
        <a  class="All "
           href="/2022/11/03/mybatis%E4%BC%A0%E5%85%A5%E5%8F%82%E6%95%B0%E5%92%8C%E8%BF%94%E5%8F%82%E6%95%B0%E7%9A%84%E6%80%BB%E7%BB%93/"
           data-tag=""
           data-author="" >
            <span class="post-title" title=""></span>
            <span class="post-date" title="2022-11-03 22:38:43">2022/11/03</span>
        </a>
        
        
        <a  class="All "
           href="/2022/11/03/mybatis%E5%BC%80%E5%8F%91/"
           data-tag=""
           data-author="" >
            <span class="post-title" title=""></span>
            <span class="post-date" title="2022-11-03 22:38:43">2022/11/03</span>
        </a>
        
        
        <a  class="All "
           href="/2022/11/03/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"
           data-tag=""
           data-author="" >
            <span class="post-title" title=""></span>
            <span class="post-date" title="2022-11-03 22:38:43">2022/11/03</span>
        </a>
        
        
        <a  class="All "
           href="/2022/11/03/win10%E7%94%B5%E8%84%91%E8%AE%BE%E7%BD%AE/"
           data-tag=""
           data-author="" >
            <span class="post-title" title=""></span>
            <span class="post-date" title="2022-11-03 22:38:43">2022/11/03</span>
        </a>
        
        
        <a  class="All "
           href="/2022/11/03/%E8%BD%AF%E8%80%83%E7%AC%94%E8%AE%B0/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="软考笔记">软考笔记</span>
            <span class="post-date" title="2022-11-03 22:34:00">2022/11/03</span>
        </a>
        
        
        <a  class="All springmvc "
           href="/2022/10/26/springmvc/Controller/"
           data-tag="springmvc"
           data-author="" >
            <span class="post-title" title="Controller">Controller</span>
            <span class="post-date" title="2022-10-26 23:06:00">2022/10/26</span>
        </a>
        
        
        <a  class="All "
           href="/2022/10/14/%E5%B7%A6%E7%A5%9E%E5%88%B7leetcode%E7%AC%94%E8%AE%B0/"
           data-tag=""
           data-author="" >
            <span class="post-title" title=""></span>
            <span class="post-date" title="2022-10-14 22:46:00">2022/10/14</span>
        </a>
        
        
        <a  class="All "
           href="/2022/10/12/Windows%E7%B3%BB%E7%BB%9F%E8%AE%BE%E7%BD%AE/win10%E7%94%B5%E8%84%91%E8%AE%BE%E7%BD%AE/"
           data-tag=""
           data-author="" >
            <span class="post-title" title=""></span>
            <span class="post-date" title="2022-10-12 11:28:00">2022/10/12</span>
        </a>
        
        
        <a  class="All "
           href="/2022/10/05/crm%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/"
           data-tag=""
           data-author="" >
            <span class="post-title" title=""></span>
            <span class="post-date" title="2022-10-05 13:35:00">2022/10/05</span>
        </a>
        
        
        <a  class="All "
           href="/2022/10/02/%E5%8D%95%E8%AF%8D/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="单词">单词</span>
            <span class="post-date" title="2022-10-02 20:57:00">2022/10/02</span>
        </a>
        
        
        <a  class="All springmvc "
           href="/2022/10/02/springmvc/ssm%E6%95%B4%E5%90%88%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9A%84%E9%85%8D%E7%BD%AE%E6%AD%A5%E9%AA%A4/"
           data-tag="springmvc"
           data-author="" >
            <span class="post-title" title="ssm整合项目配置文件的配置步骤">ssm整合项目配置文件的配置步骤</span>
            <span class="post-date" title="2022-10-02 15:53:00">2022/10/02</span>
        </a>
        
        
        <a  class="All springmvc "
           href="/2022/10/02/springmvc/springmvc%E9%85%8D%E7%BD%AEcontext%E6%A0%87%E7%AD%BE%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"
           data-tag="springmvc"
           data-author="" >
            <span class="post-title" title="springmvc配置context标签遇到的问题">springmvc配置context标签遇到的问题</span>
            <span class="post-date" title="2022-10-02 15:15:00">2022/10/02</span>
        </a>
        
        
        <a  class="All "
           href="/2022/10/01/springmvc/springmvc%E5%9B%9B%E7%A7%8D%E9%A1%B5%E9%9D%A2%E8%B7%B3%E8%BD%AC%E6%96%B9%E5%BC%8F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title=""></span>
            <span class="post-date" title="2022-10-01 14:09:03">2022/10/01</span>
        </a>
        
        
        <a  class="All IDEA "
           href="/2022/10/01/IDEA/IDEA%E4%B8%ADxml%E6%96%87%E4%BB%B6%E8%87%AA%E5%8A%A8%E8%A1%A5%E5%85%85%E4%B8%80%E4%BA%9B%E6%A0%87%E7%AD%BE/"
           data-tag="IDEA"
           data-author="" >
            <span class="post-title" title="IDEA中xml文件自动补充一些标签">IDEA中xml文件自动补充一些标签</span>
            <span class="post-date" title="2022-10-01 13:45:00">2022/10/01</span>
        </a>
        
        
        <a  class="All IDEA "
           href="/2022/10/01/IDEA/IDEA%E8%AE%BE%E7%BD%AE%E9%BB%98%E8%AE%A4%E7%BC%96%E8%AF%91%E5%99%A8/"
           data-tag="IDEA"
           data-author="" >
            <span class="post-title" title="IDEA设置默认编译器">IDEA设置默认编译器</span>
            <span class="post-date" title="2022-10-01 10:22:00">2022/10/01</span>
        </a>
        
        
        <a  class="All springmvc "
           href="/2022/09/30/springmvc/springmvc%E7%9A%84%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E6%A8%A1%E6%9D%BF/"
           data-tag="springmvc"
           data-author="" >
            <span class="post-title" title="springmvc的一个简单模板">springmvc的一个简单模板</span>
            <span class="post-date" title="2022-09-30 21:11:00">2022/09/30</span>
        </a>
        
        
        <a  class="All IDEA "
           href="/2022/09/30/IDEA/IDEA%E8%AE%BE%E7%BD%AE%E6%B3%A8%E9%87%8A%E7%9A%84%E6%A0%BC%E5%BC%8F/"
           data-tag="IDEA"
           data-author="" >
            <span class="post-title" title="IDEA设置注释的格式">IDEA设置注释的格式</span>
            <span class="post-date" title="2022-09-30 21:01:00">2022/09/30</span>
        </a>
        
        
        <a  class="All IDEA "
           href="/2022/09/24/IDEA/IDEA%E5%88%9B%E5%BB%BA%E7%A9%BA%E5%B7%A5%E7%A8%8B%E4%BC%9A%E8%87%AA%E5%8A%A8%E6%90%BA%E5%B8%A6%E5%90%8C%E5%90%8D%E6%A8%A1%E5%9D%97%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"
           data-tag="IDEA"
           data-author="" >
            <span class="post-title" title="IDEA创建空工程文件时自带同名模块的解决方法">IDEA创建空工程文件时自带同名模块的解决方法</span>
            <span class="post-date" title="2022-09-24 22:34:00">2022/09/24</span>
        </a>
        
        
        <a  class="All IDEA "
           href="/2022/09/24/IDEA/IDEA%E6%98%BE%E7%A4%BA%E5%AE%8C%E6%95%B4%E7%9A%84%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/"
           data-tag="IDEA"
           data-author="" >
            <span class="post-title" title="IDEA显示完整的目录结构">IDEA显示完整的目录结构</span>
            <span class="post-date" title="2022-09-24 22:34:00">2022/09/24</span>
        </a>
        
        
        <a  class="All JavaWeb "
           href="/2022/09/24/JavaWeb/EL%E8%A1%A8%E8%BE%BE%E5%BC%8F/"
           data-tag="JavaWeb"
           data-author="" >
            <span class="post-title" title="EL 表达式">EL 表达式</span>
            <span class="post-date" title="2022-09-24 22:34:00">2022/09/24</span>
        </a>
        
        
        <a  class="All "
           href="/2022/09/24/JavaWeb/JSTL%E6%A0%87%E7%AD%BE%E5%BA%93/"
           data-tag="JavaWeb"
           data-author="" >
            <span class="post-title" title="JSTL 标签库">JSTL 标签库</span>
            <span class="post-date" title="2022-09-24 22:34:00">2022/09/24</span>
        </a>
        
        
        <a  class="All JavaWeb "
           href="/2022/09/24/JavaWeb/session%E5%92%8Ccookie%E8%81%94%E5%90%88%E4%BD%BF%E7%94%A8%E6%97%B6%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"
           data-tag="JavaWeb"
           data-author="" >
            <span class="post-title" title="session和cookie联合使用时的注意事项">session和cookie联合使用时的注意事项</span>
            <span class="post-date" title="2022-09-24 22:34:00">2022/09/24</span>
        </a>
        
        
        <a  class="All JavaWeb "
           href="/2022/09/24/JavaWeb/%E5%AE%89%E5%85%A8%E9%80%80%E5%87%BA%E7%B3%BB%E7%BB%9F%E4%BD%BF%E7%94%A8%E9%87%8D%E5%AE%9A%E5%90%91%E5%92%8C%E8%BD%AC%E5%8F%91%E7%9A%84%E5%8C%BA%E5%88%AB/"
           data-tag="JavaWeb"
           data-author="" >
            <span class="post-title" title="安全退出系统使用重定向和转发的区别">安全退出系统使用重定向和转发的区别</span>
            <span class="post-date" title="2022-09-24 22:34:00">2022/09/24</span>
        </a>
        
        
        <a  class="All JavaWeb "
           href="/2022/09/24/JavaWeb/%E7%9B%91%E5%90%AC%E5%99%A8/"
           data-tag="JavaWeb"
           data-author="" >
            <span class="post-title" title="监听器">监听器</span>
            <span class="post-date" title="2022-09-24 22:34:00">2022/09/24</span>
        </a>
        
        
        <a  class="All JavaWeb "
           href="/2022/09/24/JavaWeb/%E8%BF%87%E6%BB%A4%E5%99%A8/"
           data-tag="JavaWeb"
           data-author="" >
            <span class="post-title" title="过滤器">过滤器</span>
            <span class="post-date" title="2022-09-24 22:34:00">2022/09/24</span>
        </a>
        
        
        <a  class="All Javase "
           href="/2022/09/24/Javase/java%20%E6%97%A0%E6%95%88%E7%9A%84%E7%9B%AE%E6%A0%87%E5%8F%91%E8%A1%8C%E7%89%88%2016/"
           data-tag="Javase"
           data-author="" >
            <span class="post-title" title="java 无效的目标发行版 16">java 无效的目标发行版 16</span>
            <span class="post-date" title="2022-09-24 22:34:00">2022/09/24</span>
        </a>
        
        
        <a  class="All esp32 "
           href="/2022/09/24/esp32/esp32%E4%B8%8A%E4%BC%A0%E6%8A%A5%E9%94%99/"
           data-tag="esp32"
           data-author="" >
            <span class="post-title" title="esp32上传报错">esp32上传报错</span>
            <span class="post-date" title="2022-09-24 22:34:00">2022/09/24</span>
        </a>
        
        
        <a  class="All mysql数据库与JDBC "
           href="/2022/09/24/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8EJDBC/IDEA%E9%85%8D%E7%BD%AE%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8F%AF%E8%A7%86%E5%8C%96/"
           data-tag="mysql数据库与JDBC"
           data-author="" >
            <span class="post-title" title="IDEA配置数据库可视化">IDEA配置数据库可视化</span>
            <span class="post-date" title="2022-09-24 22:34:00">2022/09/24</span>
        </a>
        
        
        <a  class="All JavaWeb "
           href="/2022/07/10/JavaWeb/cookie/"
           data-tag="JavaWeb"
           data-author="" >
            <span class="post-title" title="cookie">cookie</span>
            <span class="post-date" title="2022-07-10 10:37:00">2022/07/10</span>
        </a>
        
        
        <a  class="All JavaWeb "
           href="/2022/07/10/JavaWeb/session/"
           data-tag="JavaWeb"
           data-author="" >
            <span class="post-title" title="session">session</span>
            <span class="post-date" title="2022-07-10 09:14:46">2022/07/10</span>
        </a>
        
        
        <a  class="All JavaWeb "
           href="/2022/07/04/JavaWeb/%E8%BD%AC%E5%8F%91%E5%92%8C%E9%87%8D%E5%AE%9A%E5%90%91/"
           data-tag="JavaWeb"
           data-author="" >
            <span class="post-title" title="转发和重定向">转发和重定向</span>
            <span class="post-date" title="2022-07-04 16:59:00">2022/07/04</span>
        </a>
        
        
        <a  class="All JavaWeb "
           href="/2022/07/04/JavaWeb/JSP/"
           data-tag="JavaWeb"
           data-author="" >
            <span class="post-title" title="JSP">JSP</span>
            <span class="post-date" title="2022-07-04 16:57:00">2022/07/04</span>
        </a>
        
        
        <a  class="All JavaWeb "
           href="/2022/07/04/JavaWeb/%E6%B3%A8%E8%A7%A3%E5%BC%8F%E5%BC%80%E5%8F%91/"
           data-tag="JavaWeb"
           data-author="" >
            <span class="post-title" title="注解式开发">注解式开发</span>
            <span class="post-date" title="2022-07-04 16:57:00">2022/07/04</span>
        </a>
        
        
        <a  class="All 力扣刷题 "
           href="/2022/06/24/Java%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/Java%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98-%E9%A2%982/"
           data-tag="算法"
           data-author="" >
            <span class="post-title" title="Java 力扣刷题-题2">Java 力扣刷题-题2</span>
            <span class="post-date" title="2022-06-24 19:56:00">2022/06/24</span>
        </a>
        
        
        <a  class="All 个人博客 "
           href="/2022/06/24/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/%E5%B7%B2%E6%90%AC%E8%BF%90%E5%88%B0halo%E6%96%87%E7%AB%A0/Steam++%E6%8C%82%E4%BA%86%E8%BF%98%E6%98%AF%E4%B8%8A%E4%B8%8D%E5%8E%BBGithub%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"
           data-tag="个人博客,加速器"
           data-author="" >
            <span class="post-title" title="Steam++ 挂了还是上不去 Github 的解决方法">Steam++ 挂了还是上不去 Github 的解决方法</span>
            <span class="post-date" title="2022-06-24 09:28:00">2022/06/24</span>
        </a>
        
        
        <a  class="All 个人博客 "
           href="/2022/06/23/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/%E5%B7%B2%E6%90%AC%E8%BF%90%E5%88%B0halo%E6%96%87%E7%AB%A0/Hexo%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E4%B8%80%E5%8F%AA%E5%B0%8F%E7%8C%AB%E5%92%AA/"
           data-tag="个人博客"
           data-author="" >
            <span class="post-title" title="Hexo 博客添加一只小猫咪">Hexo 博客添加一只小猫咪</span>
            <span class="post-date" title="2022-06-23 20:11:00">2022/06/23</span>
        </a>
        
        
        <a  class="All 个人博客 "
           href="/2022/06/23/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/%E5%B7%B2%E6%90%AC%E8%BF%90%E5%88%B0halo%E6%96%87%E7%AB%A0/Hexo%E5%8D%9A%E5%AE%A2yilia%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE%E6%96%87%E7%AB%A0%E5%88%86%E7%B1%BB%E5%8A%9F%E8%83%BD/"
           data-tag="个人博客"
           data-author="" >
            <span class="post-title" title="Hexo 博客 yilia 主题配置文章分类功能">Hexo 博客 yilia 主题配置文章分类功能</span>
            <span class="post-date" title="2022-06-23 17:23:00">2022/06/23</span>
        </a>
        
        
        <a  class="All "
           href="/2022/06/18/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/%E5%B7%B2%E6%90%AC%E8%BF%90%E5%88%B0halo%E6%96%87%E7%AB%A0/%E8%B4%AD%E4%B9%B0%E8%85%BE%E8%AE%AF%E4%BA%91%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="购买腾讯云的服务器">购买腾讯云的服务器</span>
            <span class="post-date" title="2022-06-18 15:08:00">2022/06/18</span>
        </a>
        
        
        <a  class="All 个人博客 "
           href="/2022/06/12/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/%E5%B7%B2%E6%90%AC%E8%BF%90%E5%88%B0halo%E6%96%87%E7%AB%A0/Hexo%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F(yilia%E4%B8%BB%E9%A2%98%E4%B8%8B)/"
           data-tag="个人博客"
           data-author="" >
            <span class="post-title" title="Hexo 博客添加评论系统( yilia 主题下)">Hexo 博客添加评论系统( yilia 主题下)</span>
            <span class="post-date" title="2022-06-12 15:18:00">2022/06/12</span>
        </a>
        
        
        <a  class="All JavaWeb "
           href="/2022/06/08/JavaWeb/HttpServletRequest%E6%8E%A5%E5%8F%A3/"
           data-tag="JavaWeb"
           data-author="" >
            <span class="post-title" title="HttpServletRequest">HttpServletRequest</span>
            <span class="post-date" title="2022-06-08 22:34:00">2022/06/08</span>
        </a>
        
        
        <a  class="All JavaWeb "
           href="/2022/06/07/JavaWeb/HttpServlet/"
           data-tag="JavaWeb"
           data-author="" >
            <span class="post-title" title="HttpServlet">HttpServlet</span>
            <span class="post-date" title="2022-06-07 15:25:00">2022/06/07</span>
        </a>
        
        
        <a  class="All JavaWeb "
           href="/2022/06/07/JavaWeb/JSP%E9%85%8D%E5%90%88Servlet%E5%BC%80%E5%8F%91WEB%E7%A8%8B%E5%BA%8F/"
           data-tag="JavaWeb"
           data-author="" >
            <span class="post-title" title="JSP配合Servlet开发WEB程序">JSP配合Servlet开发WEB程序</span>
            <span class="post-date" title="2022-06-07 15:25:00">2022/06/07</span>
        </a>
        
        
        <a  class="All 个人博客 "
           href="/2022/06/06/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/%E5%B7%B2%E6%90%AC%E8%BF%90%E5%88%B0halo%E6%96%87%E7%AB%A0/XSHELL%E4%B8%8B%E8%BD%BD%E5%AE%89%E8%A3%85/"
           data-tag="个人博客"
           data-author="" >
            <span class="post-title" title="XSHELL 和 Xftp 的下载安装">XSHELL 和 Xftp 的下载安装</span>
            <span class="post-date" title="2022-06-06 11:40:00">2022/06/06</span>
        </a>
        
        
        <a  class="All JavaWeb "
           href="/2022/06/05/JavaWeb/ServletContext%E6%98%AF%E4%BB%80%E4%B9%88/"
           data-tag="JavaWeb"
           data-author="" >
            <span class="post-title" title="ServletContext 是什么">ServletContext 是什么</span>
            <span class="post-date" title="2022-06-05 20:32:00">2022/06/05</span>
        </a>
        
        
        <a  class="All JavaWeb "
           href="/2022/06/04/JavaWeb/ServletConfig%E6%98%AF%E4%BB%80%E4%B9%88/"
           data-tag="JavaWeb"
           data-author="" >
            <span class="post-title" title="ServletConfig 是什么">ServletConfig 是什么</span>
            <span class="post-date" title="2022-06-04 21:52:00">2022/06/04</span>
        </a>
        
        
        <a  class="All JavaWeb "
           href="/2022/06/04/JavaWeb/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%E6%94%B9%E9%80%A0Servlet/"
           data-tag="JavaWeb"
           data-author="" >
            <span class="post-title" title="适配器模式改造Servlet">适配器模式改造Servlet</span>
            <span class="post-date" title="2022-06-04 12:58:00">2022/06/04</span>
        </a>
        
        
        <a  class="All Javase "
           href="/2022/06/03/IDEA/IDEA%E7%9A%84%E4%B8%8B%E8%BD%BD%E5%AE%89%E8%A3%85/"
           data-tag="Javase"
           data-author="" >
            <span class="post-title" title="IDEA 的下载安装">IDEA 的下载安装</span>
            <span class="post-date" title="2022-06-03 16:58:00">2022/06/03</span>
        </a>
        
        
        <a  class="All 个人博客 "
           href="/2022/06/03/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/%E5%B7%B2%E6%90%AC%E8%BF%90%E5%88%B0halo%E6%96%87%E7%AB%A0/hexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E4%B8%8A%E4%BC%A0%E6%8A%A5%E9%94%99SSL%E8%AF%81%E4%B9%A6%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/"
           data-tag="个人博客"
           data-author="" >
            <span class="post-title" title="hexo 个人博客上传报错 SSL 证书相关问题">hexo 个人博客上传报错 SSL 证书相关问题</span>
            <span class="post-date" title="2022-06-03 14:34:00">2022/06/03</span>
        </a>
        
        
        <a  class="All JavaWeb "
           href="/2022/06/03/JavaWeb/Servlet%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"
           data-tag="JavaWeb"
           data-author="" >
            <span class="post-title" title="Servlet 对象的生命周期">Servlet 对象的生命周期</span>
            <span class="post-date" title="2022-06-03 14:15:00">2022/06/03</span>
        </a>
        
        
        <a  class="All Javase "
           href="/2022/06/01/IDEA/%E6%B3%A8%E5%86%8CIDEA%E7%9A%84%E5%AD%A6%E7%94%9F%E8%B4%A6%E5%8F%B7/"
           data-tag="Javase"
           data-author="" >
            <span class="post-title" title="注册 IDEA 的学生账号">注册 IDEA 的学生账号</span>
            <span class="post-date" title="2022-06-01 20:18:00">2022/06/01</span>
        </a>
        
        
        <a  class="All 个人博客 "
           href="/2022/06/01/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/%E5%B7%B2%E6%90%AC%E8%BF%90%E5%88%B0halo%E6%96%87%E7%AB%A0/Hexo%E5%8D%9A%E5%AE%A2%E4%B8%AA%E4%BA%BA%E5%9F%9F%E5%90%8D%E7%BB%91%E5%AE%9A%E5%8F%8A%E5%9F%9F%E5%90%8D%E5%9C%A8%E6%96%87%E7%AB%A0%E6%8E%A8%E9%80%81%E5%90%8E%E5%A4%B1%E6%95%88%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"
           data-tag="个人博客"
           data-author="" >
            <span class="post-title" title="Hexo 个人域名绑定及域名在文章推送后失效的解决方法">Hexo 个人域名绑定及域名在文章推送后失效的解决方法</span>
            <span class="post-date" title="2022-06-01 14:06:00">2022/06/01</span>
        </a>
        
        
        <a  class="All 个人博客 "
           href="/2022/05/30/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/%E5%B7%B2%E6%90%AC%E8%BF%90%E5%88%B0halo%E6%96%87%E7%AB%A0/Github%E9%85%8D%E7%BD%AEssh/"
           data-tag="个人博客"
           data-author="" >
            <span class="post-title" title="Github 配置 SSH">Github 配置 SSH</span>
            <span class="post-date" title="2022-05-30 21:22:00">2022/05/30</span>
        </a>
        
        
        <a  class="All Linux "
           href="/2022/05/30/Linux/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"
           data-tag="Linux"
           data-author="" >
            <span class="post-title" title="Linux 学习笔记">Linux 学习笔记</span>
            <span class="post-date" title="2022-05-30 20:19:00">2022/05/30</span>
        </a>
        
        
        <a  class="All Git "
           href="/2022/05/27/Git/gitee%E4%BB%93%E5%BA%93%E5%A4%87%E4%BB%BD%E6%96%87%E4%BB%B6/"
           data-tag="Git"
           data-author="" >
            <span class="post-title" title="gitee 仓库备份文件">gitee 仓库备份文件</span>
            <span class="post-date" title="2022-05-27 15:16:16">2022/05/27</span>
        </a>
        
        
        <a  class="All Windows 系统设置 "
           href="/2022/05/24/Windows%E7%B3%BB%E7%BB%9F%E8%AE%BE%E7%BD%AE/%E5%B7%B2%E6%90%AC%E8%BF%90%E5%88%B0halo%E6%96%87%E7%AB%A0/Win11%E6%98%BE%E7%A4%BA%E5%90%8E%E7%BC%80%E5%90%8D/"
           data-tag="Windows 系统设置"
           data-author="" >
            <span class="post-title" title="Win11 文件显示后缀名">Win11 文件显示后缀名</span>
            <span class="post-date" title="2022-05-24 10:40:00">2022/05/24</span>
        </a>
        
        
        <a  class="All JavaWeb "
           href="/2022/05/07/JavaWeb/%E4%BD%BF%E7%94%A8IDEA%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AATomcat%E9%A1%B9%E7%9B%AE/"
           data-tag="JavaWeb"
           data-author="" >
            <span class="post-title" title="使用 IDEA 创建一个 Tomcat 项目">使用 IDEA 创建一个 Tomcat 项目</span>
            <span class="post-date" title="2022-05-07 22:37:00">2022/05/07</span>
        </a>
        
        
        <a  class="All Javase "
           href="/2022/05/04/IDEA/IDEA%E5%9F%BA%E6%9C%AC%E8%AE%BE%E7%BD%AE/"
           data-tag="Javase"
           data-author="" >
            <span class="post-title" title="IDEA 基本设置">IDEA 基本设置</span>
            <span class="post-date" title="2022-05-04 16:21:00">2022/05/04</span>
        </a>
        
        
        <a  class="All JavaWeb "
           href="/2022/05/04/JavaWeb/Servlet%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%E7%9A%84%E7%BB%93%E6%9E%84/"
           data-tag="JavaWeb"
           data-author="" >
            <span class="post-title" title="Servlet 文件内容的结构">Servlet 文件内容的结构</span>
            <span class="post-date" title="2022-05-04 12:44:00">2022/05/04</span>
        </a>
        
        
        <a  class="All JavaWeb "
           href="/2022/05/03/JavaWeb/Tomcat%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"
           data-tag="JavaWeb"
           data-author="" >
            <span class="post-title" title="Tomcat 环境配置">Tomcat 环境配置</span>
            <span class="post-date" title="2022-05-03 22:37:00">2022/05/03</span>
        </a>
        
        
        <a  class="All 个人博客 "
           href="/2022/05/03/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/%E5%B7%B2%E6%90%AC%E8%BF%90%E5%88%B0halo%E6%96%87%E7%AB%A0/Hexo%E6%90%AD%E5%BB%BA%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0%E4%B8%8A%E4%BC%A0%E9%94%99%E8%AF%AF%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"
           data-tag="个人博客"
           data-author="" >
            <span class="post-title" title="Hexo 搭建的个人博客文章上传错误解决方法">Hexo 搭建的个人博客文章上传错误解决方法</span>
            <span class="post-date" title="2022-05-03 22:20:00">2022/05/03</span>
        </a>
        
        
        <a  class="All mysql 与 JDBC "
           href="/2022/05/03/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8EJDBC/JDBC%E7%9A%84%E4%BB%A3%E7%A0%81%E7%BB%93%E6%9E%84/"
           data-tag="mysql 与 JDBC"
           data-author="" >
            <span class="post-title" title="JDBC的代码结构">JDBC的代码结构</span>
            <span class="post-date" title="2022-05-03 21:42:00">2022/05/03</span>
        </a>
        
        
        <a  class="All "
           href="/2022/04/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E6%80%BB%E7%BB%93/"
           data-tag="Java 数据结构与算法"
           data-author="" >
            <span class="post-title" title="排序总结">排序总结</span>
            <span class="post-date" title="2022-04-09 22:25:12">2022/04/09</span>
        </a>
        
        
        <a  class="All Javase "
           href="/2022/02/27/Javase/Java%E4%B8%AD%E7%9A%84%E6%89%A9%E5%B1%95%E8%BF%90%E7%AE%97%E7%AC%A6/"
           data-tag="笔记,Java"
           data-author="" >
            <span class="post-title" title="Java中的扩展运算符">Java中的扩展运算符</span>
            <span class="post-date" title="2022-02-27 11:24:50">2022/02/27</span>
        </a>
        
        
        <a  class="All vscode "
           href="/2021/12/10/vscode%E9%94%99%E8%AF%AF/%E5%B7%B2%E6%90%AC%E8%BF%90%E5%88%B0halo%E7%9A%84%E6%96%87%E7%AB%A0/vscode%E4%B8%AD%E5%87%BA%E7%8E%B0Open-a-folder-or-workspace%E6%8A%A5%E9%94%99/"
           data-tag="vscode"
           data-author="" >
            <span class="post-title" title="vscode中出现Open a folder or workspace...报错">vscode中出现Open a folder or workspace...报错</span>
            <span class="post-date" title="2021-12-10 00:23:35">2021/12/10</span>
        </a>
        
        
        <a  class="All Git "
           href="/2021/11/29/Git/Git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"
           data-tag="Git"
           data-author="" >
            <span class="post-title" title="Git基本使用">Git基本使用</span>
            <span class="post-date" title="2021-11-29 23:03:16">2021/11/29</span>
        </a>
        
        
        <a  class="All Javase "
           href="/2021/11/21/Javase/Java-main%E6%96%B9%E6%B3%95%E4%B8%AD%E5%8F%82%E6%95%B0String-args%E7%9A%84%E7%94%A8%E6%B3%95/"
           data-tag="Javase"
           data-author="" >
            <span class="post-title" title="Java main方法中参数String[] args的用法">Java main方法中参数String[] args的用法</span>
            <span class="post-date" title="2021-11-21 11:39:57">2021/11/21</span>
        </a>
        
        
        <a  class="All Javase "
           href="/2021/11/11/Javase/Java%E6%95%B0%E7%BB%84/"
           data-tag="Javase"
           data-author="" >
            <span class="post-title" title="Java数组">Java数组</span>
            <span class="post-date" title="2021-11-11 16:54:26">2021/11/11</span>
        </a>
        
        
        <a  class="All 个人博客 "
           href="/2021/10/30/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/%E5%B7%B2%E6%90%AC%E8%BF%90%E5%88%B0halo%E6%96%87%E7%AB%A0/hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%9A%84%E7%AC%94%E8%AE%B0/"
           data-tag="个人博客"
           data-author="" >
            <span class="post-title" title="hexo搭建个人博客的笔记">hexo搭建个人博客的笔记</span>
            <span class="post-date" title="2021-10-30 21:29:07">2021/10/30</span>
        </a>
        
        
        <a  class="All 个人博客 "
           href="/2021/10/27/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/%E5%B7%B2%E6%90%AC%E8%BF%90%E5%88%B0halo%E6%96%87%E7%AB%A0/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/"
           data-tag="个人博客"
           data-author="" >
            <span class="post-title" title="我的第一篇博客文章">我的第一篇博客文章</span>
            <span class="post-date" title="2021-10-27 01:41:52">2021/10/27</span>
        </a>
        
        
        <a  class="All "
           href="/2021/10/27/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/%E5%B7%B2%E6%90%AC%E8%BF%90%E5%88%B0halo%E6%96%87%E7%AB%A0/hello-world/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Hello World">Hello World</span>
            <span class="post-date" title="2021-10-27 01:27:37">2021/10/27</span>
        </a>
        
        <div id="no-item-tips">

        </div>
    </nav>
    <div id="outline-list">
    </div>
</div>

    </div>
    <div class="hide-list">
        <div class="semicircle" data-title="切换全屏 快捷键 s">
            <div class="brackets first"><</div>
            <div class="brackets">&gt;</div>
        </div>
    </div>
</aside>
<div id="post">
    <div class="pjax">
        <article id="post-Javase/Arrays工具类" class="article article-type-post" itemscope itemprop="blogPost">
    
        <h1 class="article-title">Arrays工具类</h1>
    
    <div class="article-meta">
        
        
        
        
        <span class="tag">
            <i class="iconfont icon-tag"></i>
            
            <a class="color2">Javase</a>
            
        </span>
        
    </div>
    <div class="article-meta">
        
            Created At : <time class="date" title='Updated At: 2023-03-05 11:56:37'>2023-03-05 11:23</time>
        
    </div>
    <div class="article-meta">
        
        
        <span id="busuanzi_container_page_pv">
            Views 👀 :<span id="busuanzi_value_page_pv">
                <span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </span>
        </span>
        
        
    </div>
    
    <div class="toc-ref">
    
        
    
<style>
    .left-col .switch-btn,
    .left-col .switch-area {
        display: none;
    }
    .toc-level-3 i,
    .toc-level-3 ol {
        display: none !important;
    }
</style>
</div>
    
    <div class="article-entry" itemprop="articleBody">
      
        <span id="more"></span>

<p>查看一下这个工具类的源码，学习一下，很多内容都是机翻的，有点生硬，不过也还可以理解了。</p>
<pre><code class="java">/*
 * Copyright (c) 1997, 2014, Oracle and/or its affiliates. All rights reserved.
 * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
 */

package java.util;

import ...;

/**
 * 此类包含用于操作数组（如排序和搜索）的各种方法。此类还包含一个静态工厂，该工厂允许将数组视为列表。
 * 数组为空时会抛出 NullPointerException
 * ...
 * @author Josh Bloch
 * @author Neal Gafter
 * @author John Rose
 * @since  1.2
 */
public class Arrays &#123;

    /**
     * 使用并行加速算法的最小数组长度 1 &lt;&lt; 13 = 8192
     */
    private static final int MIN_ARRAY_SORT_GRAN = 1 &lt;&lt; 13;

    // Suppresses default constructor, ensuring non-instantiability.
    private Arrays() &#123;&#125;

    /**
     * 默认比较器
     *
       * 数组类实现者注意：与此比较器一起使用的 TimSort 相比，ComparableTimSort 是否提供任何性能优势是一个经验问题。 
       * 如果没有，您最好删除或绕过ComparableTimSort。 
       * 目前没有经验案例将它们分开以进行并行排序，因此所有公共对象并行排序方法都使用相同的基于比较器的实现。
     */
    static final class NaturalOrder implements Comparator&lt;Object&gt; &#123;
        @SuppressWarnings(&quot;unchecked&quot;)
        public int compare(Object first, Object second) &#123;
            return ((Comparable&lt;Object&gt;)first).compareTo(second);
        &#125;
        static final NaturalOrder INSTANCE = new NaturalOrder();
    &#125;

    private static void rangeCheck(int arrayLength, int fromIndex, int toIndex) &#123;
        if (fromIndex &gt; toIndex) &#123;
            throw new IllegalArgumentException(
                    &quot;fromIndex(&quot; + fromIndex + &quot;) &gt; toIndex(&quot; + toIndex + &quot;)&quot;);
        &#125;
        if (fromIndex &lt; 0) &#123;
            throw new ArrayIndexOutOfBoundsException(fromIndex);
        &#125;
        if (toIndex &gt; arrayLength) &#123;
            throw new ArrayIndexOutOfBoundsException(toIndex);
        &#125;
    &#125;

    public static void sort(int[] a) &#123;
        DualPivotQuicksort.sort(a, 0, a.length - 1, null, 0, 0);
    &#125;

    public static void sort(int[] a, int fromIndex, int toIndex) &#123;
        rangeCheck(a.length, fromIndex, toIndex);
        DualPivotQuicksort.sort(a, fromIndex, toIndex - 1, null, 0, 0);
    &#125;

    public static void sort(long[] a) &#123;
        DualPivotQuicksort.sort(a, 0, a.length - 1, null, 0, 0);
    &#125;

    public static void sort(long[] a, int fromIndex, int toIndex) &#123;
        rangeCheck(a.length, fromIndex, toIndex);
        DualPivotQuicksort.sort(a, fromIndex, toIndex - 1, null, 0, 0);
    &#125;

    public static void sort(short[] a) &#123;
        DualPivotQuicksort.sort(a, 0, a.length - 1, null, 0, 0);
    &#125;

    public static void sort(short[] a, int fromIndex, int toIndex) &#123;
        rangeCheck(a.length, fromIndex, toIndex);
        DualPivotQuicksort.sort(a, fromIndex, toIndex - 1, null, 0, 0);
    &#125;

    public static void sort(char[] a) &#123;
        DualPivotQuicksort.sort(a, 0, a.length - 1, null, 0, 0);
    &#125;

    public static void sort(char[] a, int fromIndex, int toIndex) &#123;
        rangeCheck(a.length, fromIndex, toIndex);
        DualPivotQuicksort.sort(a, fromIndex, toIndex - 1, null, 0, 0);
    &#125;

    public static void sort(byte[] a) &#123;
        DualPivotQuicksort.sort(a, 0, a.length - 1);
    &#125;

    public static void sort(byte[] a, int fromIndex, int toIndex) &#123;
        rangeCheck(a.length, fromIndex, toIndex);
        DualPivotQuicksort.sort(a, fromIndex, toIndex - 1);
    &#125;

    public static void sort(float[] a) &#123;
        DualPivotQuicksort.sort(a, 0, a.length - 1, null, 0, 0);
    &#125;

    public static void sort(float[] a, int fromIndex, int toIndex) &#123;
        rangeCheck(a.length, fromIndex, toIndex);
        DualPivotQuicksort.sort(a, fromIndex, toIndex - 1, null, 0, 0);
    &#125;

    public static void sort(double[] a) &#123;
        DualPivotQuicksort.sort(a, 0, a.length - 1, null, 0, 0);
    &#125;

    public static void sort(double[] a, int fromIndex, int toIndex) &#123;
        rangeCheck(a.length, fromIndex, toIndex);
        DualPivotQuicksort.sort(a, fromIndex, toIndex - 1, null, 0, 0);
    &#125;

    public static void parallelSort(byte[] a) &#123;
        int n = a.length, p, g;
        if (n &lt;= MIN_ARRAY_SORT_GRAN ||
            (p = ForkJoinPool.getCommonPoolParallelism()) == 1)
            DualPivotQuicksort.sort(a, 0, n - 1);
        else
            new ArraysParallelSortHelpers.FJByte.Sorter
                (null, a, new byte[n], 0, n, 0,
                 ((g = n / (p &lt;&lt; 2)) &lt;= MIN_ARRAY_SORT_GRAN) ?
                 MIN_ARRAY_SORT_GRAN : g).invoke();
    &#125;

    public static void parallelSort(byte[] a, int fromIndex, int toIndex) &#123;
        rangeCheck(a.length, fromIndex, toIndex);
        int n = toIndex - fromIndex, p, g;
        if (n &lt;= MIN_ARRAY_SORT_GRAN ||
            (p = ForkJoinPool.getCommonPoolParallelism()) == 1)
            DualPivotQuicksort.sort(a, fromIndex, toIndex - 1);
        else
            new ArraysParallelSortHelpers.FJByte.Sorter
                (null, a, new byte[n], fromIndex, n, 0,
                 ((g = n / (p &lt;&lt; 2)) &lt;= MIN_ARRAY_SORT_GRAN) ?
                 MIN_ARRAY_SORT_GRAN : g).invoke();
    &#125;

    public static void parallelSort(char[] a) &#123;
        int n = a.length, p, g;
        if (n &lt;= MIN_ARRAY_SORT_GRAN ||
            (p = ForkJoinPool.getCommonPoolParallelism()) == 1)
            DualPivotQuicksort.sort(a, 0, n - 1, null, 0, 0);
        else
            new ArraysParallelSortHelpers.FJChar.Sorter
                (null, a, new char[n], 0, n, 0,
                 ((g = n / (p &lt;&lt; 2)) &lt;= MIN_ARRAY_SORT_GRAN) ?
                 MIN_ARRAY_SORT_GRAN : g).invoke();
    &#125;

    public static void parallelSort(char[] a, int fromIndex, int toIndex) &#123;
        rangeCheck(a.length, fromIndex, toIndex);
        int n = toIndex - fromIndex, p, g;
        if (n &lt;= MIN_ARRAY_SORT_GRAN ||
            (p = ForkJoinPool.getCommonPoolParallelism()) == 1)
            DualPivotQuicksort.sort(a, fromIndex, toIndex - 1, null, 0, 0);
        else
            new ArraysParallelSortHelpers.FJChar.Sorter
                (null, a, new char[n], fromIndex, n, 0,
                 ((g = n / (p &lt;&lt; 2)) &lt;= MIN_ARRAY_SORT_GRAN) ?
                 MIN_ARRAY_SORT_GRAN : g).invoke();
    &#125;

    public static void parallelSort(short[] a) &#123;
        int n = a.length, p, g;
        if (n &lt;= MIN_ARRAY_SORT_GRAN ||
            (p = ForkJoinPool.getCommonPoolParallelism()) == 1)
            DualPivotQuicksort.sort(a, 0, n - 1, null, 0, 0);
        else
            new ArraysParallelSortHelpers.FJShort.Sorter
                (null, a, new short[n], 0, n, 0,
                 ((g = n / (p &lt;&lt; 2)) &lt;= MIN_ARRAY_SORT_GRAN) ?
                 MIN_ARRAY_SORT_GRAN : g).invoke();
    &#125;

    public static void parallelSort(short[] a, int fromIndex, int toIndex) &#123;
        rangeCheck(a.length, fromIndex, toIndex);
        int n = toIndex - fromIndex, p, g;
        if (n &lt;= MIN_ARRAY_SORT_GRAN ||
            (p = ForkJoinPool.getCommonPoolParallelism()) == 1)
            DualPivotQuicksort.sort(a, fromIndex, toIndex - 1, null, 0, 0);
        else
            new ArraysParallelSortHelpers.FJShort.Sorter
                (null, a, new short[n], fromIndex, n, 0,
                 ((g = n / (p &lt;&lt; 2)) &lt;= MIN_ARRAY_SORT_GRAN) ?
                 MIN_ARRAY_SORT_GRAN : g).invoke();
    &#125;

    public static void parallelSort(int[] a) &#123;
        int n = a.length, p, g;
        if (n &lt;= MIN_ARRAY_SORT_GRAN ||
            (p = ForkJoinPool.getCommonPoolParallelism()) == 1)
            DualPivotQuicksort.sort(a, 0, n - 1, null, 0, 0);
        else
            new ArraysParallelSortHelpers.FJInt.Sorter
                (null, a, new int[n], 0, n, 0,
                 ((g = n / (p &lt;&lt; 2)) &lt;= MIN_ARRAY_SORT_GRAN) ?
                 MIN_ARRAY_SORT_GRAN : g).invoke();
    &#125;

    public static void parallelSort(int[] a, int fromIndex, int toIndex) &#123;
        rangeCheck(a.length, fromIndex, toIndex);
        int n = toIndex - fromIndex, p, g;
        if (n &lt;= MIN_ARRAY_SORT_GRAN ||
            (p = ForkJoinPool.getCommonPoolParallelism()) == 1)
            DualPivotQuicksort.sort(a, fromIndex, toIndex - 1, null, 0, 0);
        else
            new ArraysParallelSortHelpers.FJInt.Sorter
                (null, a, new int[n], fromIndex, n, 0,
                 ((g = n / (p &lt;&lt; 2)) &lt;= MIN_ARRAY_SORT_GRAN) ?
                 MIN_ARRAY_SORT_GRAN : g).invoke();
    &#125;

    public static void parallelSort(long[] a) &#123;
        int n = a.length, p, g;
        if (n &lt;= MIN_ARRAY_SORT_GRAN ||
            (p = ForkJoinPool.getCommonPoolParallelism()) == 1)
            DualPivotQuicksort.sort(a, 0, n - 1, null, 0, 0);
        else
            new ArraysParallelSortHelpers.FJLong.Sorter
                (null, a, new long[n], 0, n, 0,
                 ((g = n / (p &lt;&lt; 2)) &lt;= MIN_ARRAY_SORT_GRAN) ?
                 MIN_ARRAY_SORT_GRAN : g).invoke();
    &#125;

    public static void parallelSort(long[] a, int fromIndex, int toIndex) &#123;
        rangeCheck(a.length, fromIndex, toIndex);
        int n = toIndex - fromIndex, p, g;
        if (n &lt;= MIN_ARRAY_SORT_GRAN ||
            (p = ForkJoinPool.getCommonPoolParallelism()) == 1)
            DualPivotQuicksort.sort(a, fromIndex, toIndex - 1, null, 0, 0);
        else
            new ArraysParallelSortHelpers.FJLong.Sorter
                (null, a, new long[n], fromIndex, n, 0,
                 ((g = n / (p &lt;&lt; 2)) &lt;= MIN_ARRAY_SORT_GRAN) ?
                 MIN_ARRAY_SORT_GRAN : g).invoke();
    &#125;
    
    public static void parallelSort(float[] a) &#123;
        int n = a.length, p, g;
        if (n &lt;= MIN_ARRAY_SORT_GRAN ||
            (p = ForkJoinPool.getCommonPoolParallelism()) == 1)
            DualPivotQuicksort.sort(a, 0, n - 1, null, 0, 0);
        else
            new ArraysParallelSortHelpers.FJFloat.Sorter
                (null, a, new float[n], 0, n, 0,
                 ((g = n / (p &lt;&lt; 2)) &lt;= MIN_ARRAY_SORT_GRAN) ?
                 MIN_ARRAY_SORT_GRAN : g).invoke();
    &#125;

    /**
     * Sorts the specified range of the array into ascending numerical order.
     * The range to be sorted extends from the index &#123;@code fromIndex&#125;,
     * inclusive, to the index &#123;@code toIndex&#125;, exclusive. If
     * &#123;@code fromIndex == toIndex&#125;, the range to be sorted is empty.
     *
     * &lt;p&gt;The &#123;@code &lt;&#125; relation does not provide a total order on all float
     * values: &#123;@code -0.0f == 0.0f&#125; is &#123;@code true&#125; and a &#123;@code Float.NaN&#125;
     * value compares neither less than, greater than, nor equal to any value,
     * even itself. This method uses the total order imposed by the method
     * &#123;@link Float#compareTo&#125;: &#123;@code -0.0f&#125; is treated as less than value
     * &#123;@code 0.0f&#125; and &#123;@code Float.NaN&#125; is considered greater than any
     * other value and all &#123;@code Float.NaN&#125; values are considered equal.
     *
     * @implNote The sorting algorithm is a parallel sort-merge that breaks the
     * array into sub-arrays that are themselves sorted and then merged. When
     * the sub-array length reaches a minimum granularity, the sub-array is
     * sorted using the appropriate &#123;@link Arrays#sort(float[]) Arrays.sort&#125;
     * method. If the length of the specified array is less than the minimum
     * granularity, then it is sorted using the appropriate &#123;@link
     * Arrays#sort(float[]) Arrays.sort&#125; method. The algorithm requires a working
     * space no greater than the size of the specified range of the original
     * array. The &#123;@link ForkJoinPool#commonPool() ForkJoin common pool&#125; is
     * used to execute any parallel tasks.
     *
     * @param a the array to be sorted
     * @param fromIndex the index of the first element, inclusive, to be sorted
     * @param toIndex the index of the last element, exclusive, to be sorted
     *
     * @throws IllegalArgumentException if &#123;@code fromIndex &gt; toIndex&#125;
     * @throws ArrayIndexOutOfBoundsException
     *     if &#123;@code fromIndex &lt; 0&#125; or &#123;@code toIndex &gt; a.length&#125;
     *
     * @since 1.8
     */
    public static void parallelSort(float[] a, int fromIndex, int toIndex) &#123;
        rangeCheck(a.length, fromIndex, toIndex);
        int n = toIndex - fromIndex, p, g;
        if (n &lt;= MIN_ARRAY_SORT_GRAN ||
            (p = ForkJoinPool.getCommonPoolParallelism()) == 1)
            DualPivotQuicksort.sort(a, fromIndex, toIndex - 1, null, 0, 0);
        else
            new ArraysParallelSortHelpers.FJFloat.Sorter
                (null, a, new float[n], fromIndex, n, 0,
                 ((g = n / (p &lt;&lt; 2)) &lt;= MIN_ARRAY_SORT_GRAN) ?
                 MIN_ARRAY_SORT_GRAN : g).invoke();
    &#125;

    /**
     * Sorts the specified array into ascending numerical order.
     *
     * &lt;p&gt;The &#123;@code &lt;&#125; relation does not provide a total order on all double
     * values: &#123;@code -0.0d == 0.0d&#125; is &#123;@code true&#125; and a &#123;@code Double.NaN&#125;
     * value compares neither less than, greater than, nor equal to any value,
     * even itself. This method uses the total order imposed by the method
     * &#123;@link Double#compareTo&#125;: &#123;@code -0.0d&#125; is treated as less than value
     * &#123;@code 0.0d&#125; and &#123;@code Double.NaN&#125; is considered greater than any
     * other value and all &#123;@code Double.NaN&#125; values are considered equal.
     *
     * @implNote The sorting algorithm is a parallel sort-merge that breaks the
     * array into sub-arrays that are themselves sorted and then merged. When
     * the sub-array length reaches a minimum granularity, the sub-array is
     * sorted using the appropriate &#123;@link Arrays#sort(double[]) Arrays.sort&#125;
     * method. If the length of the specified array is less than the minimum
     * granularity, then it is sorted using the appropriate &#123;@link
     * Arrays#sort(double[]) Arrays.sort&#125; method. The algorithm requires a
     * working space no greater than the size of the original array. The
     * &#123;@link ForkJoinPool#commonPool() ForkJoin common pool&#125; is used to
     * execute any parallel tasks.
     *
     * @param a the array to be sorted
     *
     * @since 1.8
     */
    public static void parallelSort(double[] a) &#123;
        int n = a.length, p, g;
        if (n &lt;= MIN_ARRAY_SORT_GRAN ||
            (p = ForkJoinPool.getCommonPoolParallelism()) == 1)
            DualPivotQuicksort.sort(a, 0, n - 1, null, 0, 0);
        else
            new ArraysParallelSortHelpers.FJDouble.Sorter
                (null, a, new double[n], 0, n, 0,
                 ((g = n / (p &lt;&lt; 2)) &lt;= MIN_ARRAY_SORT_GRAN) ?
                 MIN_ARRAY_SORT_GRAN : g).invoke();
    &#125;

    /**
     * Sorts the specified range of the array into ascending numerical order.
     * The range to be sorted extends from the index &#123;@code fromIndex&#125;,
     * inclusive, to the index &#123;@code toIndex&#125;, exclusive. If
     * &#123;@code fromIndex == toIndex&#125;, the range to be sorted is empty.
     *
     * &lt;p&gt;The &#123;@code &lt;&#125; relation does not provide a total order on all double
     * values: &#123;@code -0.0d == 0.0d&#125; is &#123;@code true&#125; and a &#123;@code Double.NaN&#125;
     * value compares neither less than, greater than, nor equal to any value,
     * even itself. This method uses the total order imposed by the method
     * &#123;@link Double#compareTo&#125;: &#123;@code -0.0d&#125; is treated as less than value
     * &#123;@code 0.0d&#125; and &#123;@code Double.NaN&#125; is considered greater than any
     * other value and all &#123;@code Double.NaN&#125; values are considered equal.
     *
     * @implNote The sorting algorithm is a parallel sort-merge that breaks the
     * array into sub-arrays that are themselves sorted and then merged. When
     * the sub-array length reaches a minimum granularity, the sub-array is
     * sorted using the appropriate &#123;@link Arrays#sort(double[]) Arrays.sort&#125;
     * method. If the length of the specified array is less than the minimum
     * granularity, then it is sorted using the appropriate &#123;@link
     * Arrays#sort(double[]) Arrays.sort&#125; method. The algorithm requires a working
     * space no greater than the size of the specified range of the original
     * array. The &#123;@link ForkJoinPool#commonPool() ForkJoin common pool&#125; is
     * used to execute any parallel tasks.
     *
     * @param a the array to be sorted
     * @param fromIndex the index of the first element, inclusive, to be sorted
     * @param toIndex the index of the last element, exclusive, to be sorted
     *
     * @throws IllegalArgumentException if &#123;@code fromIndex &gt; toIndex&#125;
     * @throws ArrayIndexOutOfBoundsException
     *     if &#123;@code fromIndex &lt; 0&#125; or &#123;@code toIndex &gt; a.length&#125;
     *
     * @since 1.8
     */
    public static void parallelSort(double[] a, int fromIndex, int toIndex) &#123;
        rangeCheck(a.length, fromIndex, toIndex);
        int n = toIndex - fromIndex, p, g;
        if (n &lt;= MIN_ARRAY_SORT_GRAN ||
            (p = ForkJoinPool.getCommonPoolParallelism()) == 1)
            DualPivotQuicksort.sort(a, fromIndex, toIndex - 1, null, 0, 0);
        else
            new ArraysParallelSortHelpers.FJDouble.Sorter
                (null, a, new double[n], fromIndex, n, 0,
                 ((g = n / (p &lt;&lt; 2)) &lt;= MIN_ARRAY_SORT_GRAN) ?
                 MIN_ARRAY_SORT_GRAN : g).invoke();
    &#125;

    /**
     * Sorts the specified array of objects into ascending order, according
     * to the &#123;@linkplain Comparable natural ordering&#125; of its elements.
     * All elements in the array must implement the &#123;@link Comparable&#125;
     * interface.  Furthermore, all elements in the array must be
     * &lt;i&gt;mutually comparable&lt;/i&gt; (that is, &#123;@code e1.compareTo(e2)&#125; must
     * not throw a &#123;@code ClassCastException&#125; for any elements &#123;@code e1&#125;
     * and &#123;@code e2&#125; in the array).
     *
     * &lt;p&gt;This sort is guaranteed to be &lt;i&gt;stable&lt;/i&gt;:  equal elements will
     * not be reordered as a result of the sort.
     *
     * @implNote The sorting algorithm is a parallel sort-merge that breaks the
     * array into sub-arrays that are themselves sorted and then merged. When
     * the sub-array length reaches a minimum granularity, the sub-array is
     * sorted using the appropriate &#123;@link Arrays#sort(Object[]) Arrays.sort&#125;
     * method. If the length of the specified array is less than the minimum
     * granularity, then it is sorted using the appropriate &#123;@link
     * Arrays#sort(Object[]) Arrays.sort&#125; method. The algorithm requires a
     * working space no greater than the size of the original array. The
     * &#123;@link ForkJoinPool#commonPool() ForkJoin common pool&#125; is used to
     * execute any parallel tasks.
     *
     * @param &lt;T&gt; the class of the objects to be sorted
     * @param a the array to be sorted
     *
     * @throws ClassCastException if the array contains elements that are not
     *         &lt;i&gt;mutually comparable&lt;/i&gt; (for example, strings and integers)
     * @throws IllegalArgumentException (optional) if the natural
     *         ordering of the array elements is found to violate the
     *         &#123;@link Comparable&#125; contract
     *
     * @since 1.8
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;T extends Comparable&lt;? super T&gt;&gt; void parallelSort(T[] a) &#123;
        int n = a.length, p, g;
        if (n &lt;= MIN_ARRAY_SORT_GRAN ||
            (p = ForkJoinPool.getCommonPoolParallelism()) == 1)
            TimSort.sort(a, 0, n, NaturalOrder.INSTANCE, null, 0, 0);
        else
            new ArraysParallelSortHelpers.FJObject.Sorter&lt;T&gt;
                (null, a,
                 (T[])Array.newInstance(a.getClass().getComponentType(), n),
                 0, n, 0, ((g = n / (p &lt;&lt; 2)) &lt;= MIN_ARRAY_SORT_GRAN) ?
                 MIN_ARRAY_SORT_GRAN : g, NaturalOrder.INSTANCE).invoke();
    &#125;

    /**
     * Sorts the specified range of the specified array of objects into
     * ascending order, according to the
     * &#123;@linkplain Comparable natural ordering&#125; of its
     * elements.  The range to be sorted extends from index
     * &#123;@code fromIndex&#125;, inclusive, to index &#123;@code toIndex&#125;, exclusive.
     * (If &#123;@code fromIndex==toIndex&#125;, the range to be sorted is empty.)  All
     * elements in this range must implement the &#123;@link Comparable&#125;
     * interface.  Furthermore, all elements in this range must be &lt;i&gt;mutually
     * comparable&lt;/i&gt; (that is, &#123;@code e1.compareTo(e2)&#125; must not throw a
     * &#123;@code ClassCastException&#125; for any elements &#123;@code e1&#125; and
     * &#123;@code e2&#125; in the array).
     *
     * &lt;p&gt;This sort is guaranteed to be &lt;i&gt;stable&lt;/i&gt;:  equal elements will
     * not be reordered as a result of the sort.
     *
     * @implNote The sorting algorithm is a parallel sort-merge that breaks the
     * array into sub-arrays that are themselves sorted and then merged. When
     * the sub-array length reaches a minimum granularity, the sub-array is
     * sorted using the appropriate &#123;@link Arrays#sort(Object[]) Arrays.sort&#125;
     * method. If the length of the specified array is less than the minimum
     * granularity, then it is sorted using the appropriate &#123;@link
     * Arrays#sort(Object[]) Arrays.sort&#125; method. The algorithm requires a working
     * space no greater than the size of the specified range of the original
     * array. The &#123;@link ForkJoinPool#commonPool() ForkJoin common pool&#125; is
     * used to execute any parallel tasks.
     *
     * @param &lt;T&gt; the class of the objects to be sorted
     * @param a the array to be sorted
     * @param fromIndex the index of the first element (inclusive) to be
     *        sorted
     * @param toIndex the index of the last element (exclusive) to be sorted
     * @throws IllegalArgumentException if &#123;@code fromIndex &gt; toIndex&#125; or
     *         (optional) if the natural ordering of the array elements is
     *         found to violate the &#123;@link Comparable&#125; contract
     * @throws ArrayIndexOutOfBoundsException if &#123;@code fromIndex &lt; 0&#125; or
     *         &#123;@code toIndex &gt; a.length&#125;
     * @throws ClassCastException if the array contains elements that are
     *         not &lt;i&gt;mutually comparable&lt;/i&gt; (for example, strings and
     *         integers).
     *
     * @since 1.8
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;T extends Comparable&lt;? super T&gt;&gt;
    void parallelSort(T[] a, int fromIndex, int toIndex) &#123;
        rangeCheck(a.length, fromIndex, toIndex);
        int n = toIndex - fromIndex, p, g;
        if (n &lt;= MIN_ARRAY_SORT_GRAN ||
            (p = ForkJoinPool.getCommonPoolParallelism()) == 1)
            TimSort.sort(a, fromIndex, toIndex, NaturalOrder.INSTANCE, null, 0, 0);
        else
            new ArraysParallelSortHelpers.FJObject.Sorter&lt;T&gt;
                (null, a,
                 (T[])Array.newInstance(a.getClass().getComponentType(), n),
                 fromIndex, n, 0, ((g = n / (p &lt;&lt; 2)) &lt;= MIN_ARRAY_SORT_GRAN) ?
                 MIN_ARRAY_SORT_GRAN : g, NaturalOrder.INSTANCE).invoke();
    &#125;

    /**
     * Sorts the specified array of objects according to the order induced by
     * the specified comparator.  All elements in the array must be
     * &lt;i&gt;mutually comparable&lt;/i&gt; by the specified comparator (that is,
     * &#123;@code c.compare(e1, e2)&#125; must not throw a &#123;@code ClassCastException&#125;
     * for any elements &#123;@code e1&#125; and &#123;@code e2&#125; in the array).
     *
     * &lt;p&gt;This sort is guaranteed to be &lt;i&gt;stable&lt;/i&gt;:  equal elements will
     * not be reordered as a result of the sort.
     *
     * @implNote The sorting algorithm is a parallel sort-merge that breaks the
     * array into sub-arrays that are themselves sorted and then merged. When
     * the sub-array length reaches a minimum granularity, the sub-array is
     * sorted using the appropriate &#123;@link Arrays#sort(Object[]) Arrays.sort&#125;
     * method. If the length of the specified array is less than the minimum
     * granularity, then it is sorted using the appropriate &#123;@link
     * Arrays#sort(Object[]) Arrays.sort&#125; method. The algorithm requires a
     * working space no greater than the size of the original array. The
     * &#123;@link ForkJoinPool#commonPool() ForkJoin common pool&#125; is used to
     * execute any parallel tasks.
     *
     * @param &lt;T&gt; the class of the objects to be sorted
     * @param a the array to be sorted
     * @param cmp the comparator to determine the order of the array.  A
     *        &#123;@code null&#125; value indicates that the elements&#39;
     *        &#123;@linkplain Comparable natural ordering&#125; should be used.
     * @throws ClassCastException if the array contains elements that are
     *         not &lt;i&gt;mutually comparable&lt;/i&gt; using the specified comparator
     * @throws IllegalArgumentException (optional) if the comparator is
     *         found to violate the &#123;@link java.util.Comparator&#125; contract
     *
     * @since 1.8
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;T&gt; void parallelSort(T[] a, Comparator&lt;? super T&gt; cmp) &#123;
        if (cmp == null)
            cmp = NaturalOrder.INSTANCE;
        int n = a.length, p, g;
        if (n &lt;= MIN_ARRAY_SORT_GRAN ||
            (p = ForkJoinPool.getCommonPoolParallelism()) == 1)
            TimSort.sort(a, 0, n, cmp, null, 0, 0);
        else
            new ArraysParallelSortHelpers.FJObject.Sorter&lt;T&gt;
                (null, a,
                 (T[])Array.newInstance(a.getClass().getComponentType(), n),
                 0, n, 0, ((g = n / (p &lt;&lt; 2)) &lt;= MIN_ARRAY_SORT_GRAN) ?
                 MIN_ARRAY_SORT_GRAN : g, cmp).invoke();
    &#125;

    /**
     * Sorts the specified range of the specified array of objects according
     * to the order induced by the specified comparator.  The range to be
     * sorted extends from index &#123;@code fromIndex&#125;, inclusive, to index
     * &#123;@code toIndex&#125;, exclusive.  (If &#123;@code fromIndex==toIndex&#125;, the
     * range to be sorted is empty.)  All elements in the range must be
     * &lt;i&gt;mutually comparable&lt;/i&gt; by the specified comparator (that is,
     * &#123;@code c.compare(e1, e2)&#125; must not throw a &#123;@code ClassCastException&#125;
     * for any elements &#123;@code e1&#125; and &#123;@code e2&#125; in the range).
     *
     * &lt;p&gt;This sort is guaranteed to be &lt;i&gt;stable&lt;/i&gt;:  equal elements will
     * not be reordered as a result of the sort.
     *
     * @implNote The sorting algorithm is a parallel sort-merge that breaks the
     * array into sub-arrays that are themselves sorted and then merged. When
     * the sub-array length reaches a minimum granularity, the sub-array is
     * sorted using the appropriate &#123;@link Arrays#sort(Object[]) Arrays.sort&#125;
     * method. If the length of the specified array is less than the minimum
     * granularity, then it is sorted using the appropriate &#123;@link
     * Arrays#sort(Object[]) Arrays.sort&#125; method. The algorithm requires a working
     * space no greater than the size of the specified range of the original
     * array. The &#123;@link ForkJoinPool#commonPool() ForkJoin common pool&#125; is
     * used to execute any parallel tasks.
     *
     * @param &lt;T&gt; the class of the objects to be sorted
     * @param a the array to be sorted
     * @param fromIndex the index of the first element (inclusive) to be
     *        sorted
     * @param toIndex the index of the last element (exclusive) to be sorted
     * @param cmp the comparator to determine the order of the array.  A
     *        &#123;@code null&#125; value indicates that the elements&#39;
     *        &#123;@linkplain Comparable natural ordering&#125; should be used.
     * @throws IllegalArgumentException if &#123;@code fromIndex &gt; toIndex&#125; or
     *         (optional) if the natural ordering of the array elements is
     *         found to violate the &#123;@link Comparable&#125; contract
     * @throws ArrayIndexOutOfBoundsException if &#123;@code fromIndex &lt; 0&#125; or
     *         &#123;@code toIndex &gt; a.length&#125;
     * @throws ClassCastException if the array contains elements that are
     *         not &lt;i&gt;mutually comparable&lt;/i&gt; (for example, strings and
     *         integers).
     *
     * @since 1.8
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;T&gt; void parallelSort(T[] a, int fromIndex, int toIndex,
                                        Comparator&lt;? super T&gt; cmp) &#123;
        rangeCheck(a.length, fromIndex, toIndex);
        if (cmp == null)
            cmp = NaturalOrder.INSTANCE;
        int n = toIndex - fromIndex, p, g;
        if (n &lt;= MIN_ARRAY_SORT_GRAN ||
            (p = ForkJoinPool.getCommonPoolParallelism()) == 1)
            TimSort.sort(a, fromIndex, toIndex, cmp, null, 0, 0);
        else
            new ArraysParallelSortHelpers.FJObject.Sorter&lt;T&gt;
                (null, a,
                 (T[])Array.newInstance(a.getClass().getComponentType(), n),
                 fromIndex, n, 0, ((g = n / (p &lt;&lt; 2)) &lt;= MIN_ARRAY_SORT_GRAN) ?
                 MIN_ARRAY_SORT_GRAN : g, cmp).invoke();
    &#125;

    /*
     * Sorting of complex type arrays.
     */

    /**
     * Old merge sort implementation can be selected (for
     * compatibility with broken comparators) using a system property.
     * Cannot be a static boolean in the enclosing class due to
     * circular dependencies. To be removed in a future release.
     */
    static final class LegacyMergeSort &#123;
        private static final boolean userRequested =
            java.security.AccessController.doPrivileged(
                new sun.security.action.GetBooleanAction(
                    &quot;java.util.Arrays.useLegacyMergeSort&quot;)).booleanValue();
    &#125;

    /**
     * Sorts the specified array of objects into ascending order, according
     * to the &#123;@linkplain Comparable natural ordering&#125; of its elements.
     * All elements in the array must implement the &#123;@link Comparable&#125;
     * interface.  Furthermore, all elements in the array must be
     * &lt;i&gt;mutually comparable&lt;/i&gt; (that is, &#123;@code e1.compareTo(e2)&#125; must
     * not throw a &#123;@code ClassCastException&#125; for any elements &#123;@code e1&#125;
     * and &#123;@code e2&#125; in the array).
     *
     * &lt;p&gt;This sort is guaranteed to be &lt;i&gt;stable&lt;/i&gt;:  equal elements will
     * not be reordered as a result of the sort.
     *
     * &lt;p&gt;Implementation note: This implementation is a stable, adaptive,
     * iterative mergesort that requires far fewer than n lg(n) comparisons
     * when the input array is partially sorted, while offering the
     * performance of a traditional mergesort when the input array is
     * randomly ordered.  If the input array is nearly sorted, the
     * implementation requires approximately n comparisons.  Temporary
     * storage requirements vary from a small constant for nearly sorted
     * input arrays to n/2 object references for randomly ordered input
     * arrays.
     *
     * &lt;p&gt;The implementation takes equal advantage of ascending and
     * descending order in its input array, and can take advantage of
     * ascending and descending order in different parts of the the same
     * input array.  It is well-suited to merging two or more sorted arrays:
     * simply concatenate the arrays and sort the resulting array.
     *
     * &lt;p&gt;The implementation was adapted from Tim Peters&#39;s list sort for Python
     * (&lt;a href=&quot;http://svn.python.org/projects/python/trunk/Objects/listsort.txt&quot;&gt;
     * TimSort&lt;/a&gt;).  It uses techniques from Peter McIlroy&#39;s &quot;Optimistic
     * Sorting and Information Theoretic Complexity&quot;, in Proceedings of the
     * Fourth Annual ACM-SIAM Symposium on Discrete Algorithms, pp 467-474,
     * January 1993.
     *
     * @param a the array to be sorted
     * @throws ClassCastException if the array contains elements that are not
     *         &lt;i&gt;mutually comparable&lt;/i&gt; (for example, strings and integers)
     * @throws IllegalArgumentException (optional) if the natural
     *         ordering of the array elements is found to violate the
     *         &#123;@link Comparable&#125; contract
     */
    public static void sort(Object[] a) &#123;
        if (LegacyMergeSort.userRequested)
            legacyMergeSort(a);
        else
            ComparableTimSort.sort(a, 0, a.length, null, 0, 0);
    &#125;

    /** To be removed in a future release. */
    private static void legacyMergeSort(Object[] a) &#123;
        Object[] aux = a.clone();
        mergeSort(aux, a, 0, a.length, 0);
    &#125;

    /**
     * Sorts the specified range of the specified array of objects into
     * ascending order, according to the
     * &#123;@linkplain Comparable natural ordering&#125; of its
     * elements.  The range to be sorted extends from index
     * &#123;@code fromIndex&#125;, inclusive, to index &#123;@code toIndex&#125;, exclusive.
     * (If &#123;@code fromIndex==toIndex&#125;, the range to be sorted is empty.)  All
     * elements in this range must implement the &#123;@link Comparable&#125;
     * interface.  Furthermore, all elements in this range must be &lt;i&gt;mutually
     * comparable&lt;/i&gt; (that is, &#123;@code e1.compareTo(e2)&#125; must not throw a
     * &#123;@code ClassCastException&#125; for any elements &#123;@code e1&#125; and
     * &#123;@code e2&#125; in the array).
     *
     * &lt;p&gt;This sort is guaranteed to be &lt;i&gt;stable&lt;/i&gt;:  equal elements will
     * not be reordered as a result of the sort.
     *
     * &lt;p&gt;Implementation note: This implementation is a stable, adaptive,
     * iterative mergesort that requires far fewer than n lg(n) comparisons
     * when the input array is partially sorted, while offering the
     * performance of a traditional mergesort when the input array is
     * randomly ordered.  If the input array is nearly sorted, the
     * implementation requires approximately n comparisons.  Temporary
     * storage requirements vary from a small constant for nearly sorted
     * input arrays to n/2 object references for randomly ordered input
     * arrays.
     *
     * &lt;p&gt;The implementation takes equal advantage of ascending and
     * descending order in its input array, and can take advantage of
     * ascending and descending order in different parts of the the same
     * input array.  It is well-suited to merging two or more sorted arrays:
     * simply concatenate the arrays and sort the resulting array.
     *
     * &lt;p&gt;The implementation was adapted from Tim Peters&#39;s list sort for Python
     * (&lt;a href=&quot;http://svn.python.org/projects/python/trunk/Objects/listsort.txt&quot;&gt;
     * TimSort&lt;/a&gt;).  It uses techniques from Peter McIlroy&#39;s &quot;Optimistic
     * Sorting and Information Theoretic Complexity&quot;, in Proceedings of the
     * Fourth Annual ACM-SIAM Symposium on Discrete Algorithms, pp 467-474,
     * January 1993.
     *
     * @param a the array to be sorted
     * @param fromIndex the index of the first element (inclusive) to be
     *        sorted
     * @param toIndex the index of the last element (exclusive) to be sorted
     * @throws IllegalArgumentException if &#123;@code fromIndex &gt; toIndex&#125; or
     *         (optional) if the natural ordering of the array elements is
     *         found to violate the &#123;@link Comparable&#125; contract
     * @throws ArrayIndexOutOfBoundsException if &#123;@code fromIndex &lt; 0&#125; or
     *         &#123;@code toIndex &gt; a.length&#125;
     * @throws ClassCastException if the array contains elements that are
     *         not &lt;i&gt;mutually comparable&lt;/i&gt; (for example, strings and
     *         integers).
     */
    public static void sort(Object[] a, int fromIndex, int toIndex) &#123;
        rangeCheck(a.length, fromIndex, toIndex);
        if (LegacyMergeSort.userRequested)
            legacyMergeSort(a, fromIndex, toIndex);
        else
            ComparableTimSort.sort(a, fromIndex, toIndex, null, 0, 0);
    &#125;

    /** To be removed in a future release. */
    private static void legacyMergeSort(Object[] a,
                                        int fromIndex, int toIndex) &#123;
        Object[] aux = copyOfRange(a, fromIndex, toIndex);
        mergeSort(aux, a, fromIndex, toIndex, -fromIndex);
    &#125;

    /**
     * Tuning parameter: list size at or below which insertion sort will be
     * used in preference to mergesort.
     * To be removed in a future release.
     */
    private static final int INSERTIONSORT_THRESHOLD = 7;

    /**
     * Src is the source array that starts at index 0
     * Dest is the (possibly larger) array destination with a possible offset
     * low is the index in dest to start sorting
     * high is the end index in dest to end sorting
     * off is the offset to generate corresponding low, high in src
     * To be removed in a future release.
     */
    @SuppressWarnings(&#123;&quot;unchecked&quot;, &quot;rawtypes&quot;&#125;)
    private static void mergeSort(Object[] src,
                                  Object[] dest,
                                  int low,
                                  int high,
                                  int off) &#123;
        int length = high - low;

        // Insertion sort on smallest arrays
        if (length &lt; INSERTIONSORT_THRESHOLD) &#123;
            for (int i=low; i&lt;high; i++)
                for (int j=i; j&gt;low &amp;&amp;
                         ((Comparable) dest[j-1]).compareTo(dest[j])&gt;0; j--)
                    swap(dest, j, j-1);
            return;
        &#125;

        // Recursively sort halves of dest into src
        int destLow  = low;
        int destHigh = high;
        low  += off;
        high += off;
        int mid = (low + high) &gt;&gt;&gt; 1;
        mergeSort(dest, src, low, mid, -off);
        mergeSort(dest, src, mid, high, -off);

        // If list is already sorted, just copy from src to dest.  This is an
        // optimization that results in faster sorts for nearly ordered lists.
        if (((Comparable)src[mid-1]).compareTo(src[mid]) &lt;= 0) &#123;
            System.arraycopy(src, low, dest, destLow, length);
            return;
        &#125;

        // Merge sorted halves (now in src) into dest
        for(int i = destLow, p = low, q = mid; i &lt; destHigh; i++) &#123;
            if (q &gt;= high || p &lt; mid &amp;&amp; ((Comparable)src[p]).compareTo(src[q])&lt;=0)
                dest[i] = src[p++];
            else
                dest[i] = src[q++];
        &#125;
    &#125;

    /**
     * Swaps x[a] with x[b].
     */
    private static void swap(Object[] x, int a, int b) &#123;
        Object t = x[a];
        x[a] = x[b];
        x[b] = t;
    &#125;

    /**
     * Sorts the specified array of objects according to the order induced by
     * the specified comparator.  All elements in the array must be
     * &lt;i&gt;mutually comparable&lt;/i&gt; by the specified comparator (that is,
     * &#123;@code c.compare(e1, e2)&#125; must not throw a &#123;@code ClassCastException&#125;
     * for any elements &#123;@code e1&#125; and &#123;@code e2&#125; in the array).
     *
     * &lt;p&gt;This sort is guaranteed to be &lt;i&gt;stable&lt;/i&gt;:  equal elements will
     * not be reordered as a result of the sort.
     *
     * &lt;p&gt;Implementation note: This implementation is a stable, adaptive,
     * iterative mergesort that requires far fewer than n lg(n) comparisons
     * when the input array is partially sorted, while offering the
     * performance of a traditional mergesort when the input array is
     * randomly ordered.  If the input array is nearly sorted, the
     * implementation requires approximately n comparisons.  Temporary
     * storage requirements vary from a small constant for nearly sorted
     * input arrays to n/2 object references for randomly ordered input
     * arrays.
     *
     * &lt;p&gt;The implementation takes equal advantage of ascending and
     * descending order in its input array, and can take advantage of
     * ascending and descending order in different parts of the the same
     * input array.  It is well-suited to merging two or more sorted arrays:
     * simply concatenate the arrays and sort the resulting array.
     *
     * &lt;p&gt;The implementation was adapted from Tim Peters&#39;s list sort for Python
     * (&lt;a href=&quot;http://svn.python.org/projects/python/trunk/Objects/listsort.txt&quot;&gt;
     * TimSort&lt;/a&gt;).  It uses techniques from Peter McIlroy&#39;s &quot;Optimistic
     * Sorting and Information Theoretic Complexity&quot;, in Proceedings of the
     * Fourth Annual ACM-SIAM Symposium on Discrete Algorithms, pp 467-474,
     * January 1993.
     *
     * @param &lt;T&gt; the class of the objects to be sorted
     * @param a the array to be sorted
     * @param c the comparator to determine the order of the array.  A
     *        &#123;@code null&#125; value indicates that the elements&#39;
     *        &#123;@linkplain Comparable natural ordering&#125; should be used.
     * @throws ClassCastException if the array contains elements that are
     *         not &lt;i&gt;mutually comparable&lt;/i&gt; using the specified comparator
     * @throws IllegalArgumentException (optional) if the comparator is
     *         found to violate the &#123;@link Comparator&#125; contract
     */
    public static &lt;T&gt; void sort(T[] a, Comparator&lt;? super T&gt; c) &#123;
        if (c == null) &#123;
            sort(a);
        &#125; else &#123;
            if (LegacyMergeSort.userRequested)
                legacyMergeSort(a, c);
            else
                TimSort.sort(a, 0, a.length, c, null, 0, 0);
        &#125;
    &#125;

    /** To be removed in a future release. */
    private static &lt;T&gt; void legacyMergeSort(T[] a, Comparator&lt;? super T&gt; c) &#123;
        T[] aux = a.clone();
        if (c==null)
            mergeSort(aux, a, 0, a.length, 0);
        else
            mergeSort(aux, a, 0, a.length, 0, c);
    &#125;

    /**
     * Sorts the specified range of the specified array of objects according
     * to the order induced by the specified comparator.  The range to be
     * sorted extends from index &#123;@code fromIndex&#125;, inclusive, to index
     * &#123;@code toIndex&#125;, exclusive.  (If &#123;@code fromIndex==toIndex&#125;, the
     * range to be sorted is empty.)  All elements in the range must be
     * &lt;i&gt;mutually comparable&lt;/i&gt; by the specified comparator (that is,
     * &#123;@code c.compare(e1, e2)&#125; must not throw a &#123;@code ClassCastException&#125;
     * for any elements &#123;@code e1&#125; and &#123;@code e2&#125; in the range).
     *
     * &lt;p&gt;This sort is guaranteed to be &lt;i&gt;stable&lt;/i&gt;:  equal elements will
     * not be reordered as a result of the sort.
     *
     * &lt;p&gt;Implementation note: This implementation is a stable, adaptive,
     * iterative mergesort that requires far fewer than n lg(n) comparisons
     * when the input array is partially sorted, while offering the
     * performance of a traditional mergesort when the input array is
     * randomly ordered.  If the input array is nearly sorted, the
     * implementation requires approximately n comparisons.  Temporary
     * storage requirements vary from a small constant for nearly sorted
     * input arrays to n/2 object references for randomly ordered input
     * arrays.
     *
     * &lt;p&gt;The implementation takes equal advantage of ascending and
     * descending order in its input array, and can take advantage of
     * ascending and descending order in different parts of the the same
     * input array.  It is well-suited to merging two or more sorted arrays:
     * simply concatenate the arrays and sort the resulting array.
     *
     * &lt;p&gt;The implementation was adapted from Tim Peters&#39;s list sort for Python
     * (&lt;a href=&quot;http://svn.python.org/projects/python/trunk/Objects/listsort.txt&quot;&gt;
     * TimSort&lt;/a&gt;).  It uses techniques from Peter McIlroy&#39;s &quot;Optimistic
     * Sorting and Information Theoretic Complexity&quot;, in Proceedings of the
     * Fourth Annual ACM-SIAM Symposium on Discrete Algorithms, pp 467-474,
     * January 1993.
     *
     * @param &lt;T&gt; the class of the objects to be sorted
     * @param a the array to be sorted
     * @param fromIndex the index of the first element (inclusive) to be
     *        sorted
     * @param toIndex the index of the last element (exclusive) to be sorted
     * @param c the comparator to determine the order of the array.  A
     *        &#123;@code null&#125; value indicates that the elements&#39;
     *        &#123;@linkplain Comparable natural ordering&#125; should be used.
     * @throws ClassCastException if the array contains elements that are not
     *         &lt;i&gt;mutually comparable&lt;/i&gt; using the specified comparator.
     * @throws IllegalArgumentException if &#123;@code fromIndex &gt; toIndex&#125; or
     *         (optional) if the comparator is found to violate the
     *         &#123;@link Comparator&#125; contract
     * @throws ArrayIndexOutOfBoundsException if &#123;@code fromIndex &lt; 0&#125; or
     *         &#123;@code toIndex &gt; a.length&#125;
     */
    public static &lt;T&gt; void sort(T[] a, int fromIndex, int toIndex,
                                Comparator&lt;? super T&gt; c) &#123;
        if (c == null) &#123;
            sort(a, fromIndex, toIndex);
        &#125; else &#123;
            rangeCheck(a.length, fromIndex, toIndex);
            if (LegacyMergeSort.userRequested)
                legacyMergeSort(a, fromIndex, toIndex, c);
            else
                TimSort.sort(a, fromIndex, toIndex, c, null, 0, 0);
        &#125;
    &#125;

    /** To be removed in a future release. */
    private static &lt;T&gt; void legacyMergeSort(T[] a, int fromIndex, int toIndex,
                                            Comparator&lt;? super T&gt; c) &#123;
        T[] aux = copyOfRange(a, fromIndex, toIndex);
        if (c==null)
            mergeSort(aux, a, fromIndex, toIndex, -fromIndex);
        else
            mergeSort(aux, a, fromIndex, toIndex, -fromIndex, c);
    &#125;

    /**
     * Src is the source array that starts at index 0
     * Dest is the (possibly larger) array destination with a possible offset
     * low is the index in dest to start sorting
     * high is the end index in dest to end sorting
     * off is the offset into src corresponding to low in dest
     * To be removed in a future release.
     */
    @SuppressWarnings(&#123;&quot;rawtypes&quot;, &quot;unchecked&quot;&#125;)
    private static void mergeSort(Object[] src,
                                  Object[] dest,
                                  int low, int high, int off,
                                  Comparator c) &#123;
        int length = high - low;

        // Insertion sort on smallest arrays
        if (length &lt; INSERTIONSORT_THRESHOLD) &#123;
            for (int i=low; i&lt;high; i++)
                for (int j=i; j&gt;low &amp;&amp; c.compare(dest[j-1], dest[j])&gt;0; j--)
                    swap(dest, j, j-1);
            return;
        &#125;

        // Recursively sort halves of dest into src
        int destLow  = low;
        int destHigh = high;
        low  += off;
        high += off;
        int mid = (low + high) &gt;&gt;&gt; 1;
        mergeSort(dest, src, low, mid, -off, c);
        mergeSort(dest, src, mid, high, -off, c);

        // If list is already sorted, just copy from src to dest.  This is an
        // optimization that results in faster sorts for nearly ordered lists.
        if (c.compare(src[mid-1], src[mid]) &lt;= 0) &#123;
           System.arraycopy(src, low, dest, destLow, length);
           return;
        &#125;

        // Merge sorted halves (now in src) into dest
        for(int i = destLow, p = low, q = mid; i &lt; destHigh; i++) &#123;
            if (q &gt;= high || p &lt; mid &amp;&amp; c.compare(src[p], src[q]) &lt;= 0)
                dest[i] = src[p++];
            else
                dest[i] = src[q++];
        &#125;
    &#125;

    // Parallel prefix

    /**
     * Cumulates, in parallel, each element of the given array in place,
     * using the supplied function. For example if the array initially
     * holds &#123;@code [2, 1, 0, 3]&#125; and the operation performs addition,
     * then upon return the array holds &#123;@code [2, 3, 3, 6]&#125;.
     * Parallel prefix computation is usually more efficient than
     * sequential loops for large arrays.
     *
     * @param &lt;T&gt; the class of the objects in the array
     * @param array the array, which is modified in-place by this method
     * @param op a side-effect-free, associative function to perform the
     * cumulation
     * @throws NullPointerException if the specified array or function is null
     * @since 1.8
     */
    public static &lt;T&gt; void parallelPrefix(T[] array, BinaryOperator&lt;T&gt; op) &#123;
        Objects.requireNonNull(op);
        if (array.length &gt; 0)
            new ArrayPrefixHelpers.CumulateTask&lt;&gt;
                    (null, op, array, 0, array.length).invoke();
    &#125;

    /**
     * Performs &#123;@link #parallelPrefix(Object[], BinaryOperator)&#125;
     * for the given subrange of the array.
     *
     * @param &lt;T&gt; the class of the objects in the array
     * @param array the array
     * @param fromIndex the index of the first element, inclusive
     * @param toIndex the index of the last element, exclusive
     * @param op a side-effect-free, associative function to perform the
     * cumulation
     * @throws IllegalArgumentException if &#123;@code fromIndex &gt; toIndex&#125;
     * @throws ArrayIndexOutOfBoundsException
     *     if &#123;@code fromIndex &lt; 0&#125; or &#123;@code toIndex &gt; array.length&#125;
     * @throws NullPointerException if the specified array or function is null
     * @since 1.8
     */
    public static &lt;T&gt; void parallelPrefix(T[] array, int fromIndex,
                                          int toIndex, BinaryOperator&lt;T&gt; op) &#123;
        Objects.requireNonNull(op);
        rangeCheck(array.length, fromIndex, toIndex);
        if (fromIndex &lt; toIndex)
            new ArrayPrefixHelpers.CumulateTask&lt;&gt;
                    (null, op, array, fromIndex, toIndex).invoke();
    &#125;

    /**
     * Cumulates, in parallel, each element of the given array in place,
     * using the supplied function. For example if the array initially
     * holds &#123;@code [2, 1, 0, 3]&#125; and the operation performs addition,
     * then upon return the array holds &#123;@code [2, 3, 3, 6]&#125;.
     * Parallel prefix computation is usually more efficient than
     * sequential loops for large arrays.
     *
     * @param array the array, which is modified in-place by this method
     * @param op a side-effect-free, associative function to perform the
     * cumulation
     * @throws NullPointerException if the specified array or function is null
     * @since 1.8
     */
    public static void parallelPrefix(long[] array, LongBinaryOperator op) &#123;
        Objects.requireNonNull(op);
        if (array.length &gt; 0)
            new ArrayPrefixHelpers.LongCumulateTask
                    (null, op, array, 0, array.length).invoke();
    &#125;

    /**
     * Performs &#123;@link #parallelPrefix(long[], LongBinaryOperator)&#125;
     * for the given subrange of the array.
     *
     * @param array the array
     * @param fromIndex the index of the first element, inclusive
     * @param toIndex the index of the last element, exclusive
     * @param op a side-effect-free, associative function to perform the
     * cumulation
     * @throws IllegalArgumentException if &#123;@code fromIndex &gt; toIndex&#125;
     * @throws ArrayIndexOutOfBoundsException
     *     if &#123;@code fromIndex &lt; 0&#125; or &#123;@code toIndex &gt; array.length&#125;
     * @throws NullPointerException if the specified array or function is null
     * @since 1.8
     */
    public static void parallelPrefix(long[] array, int fromIndex,
                                      int toIndex, LongBinaryOperator op) &#123;
        Objects.requireNonNull(op);
        rangeCheck(array.length, fromIndex, toIndex);
        if (fromIndex &lt; toIndex)
            new ArrayPrefixHelpers.LongCumulateTask
                    (null, op, array, fromIndex, toIndex).invoke();
    &#125;

    /**
     * Cumulates, in parallel, each element of the given array in place,
     * using the supplied function. For example if the array initially
     * holds &#123;@code [2.0, 1.0, 0.0, 3.0]&#125; and the operation performs addition,
     * then upon return the array holds &#123;@code [2.0, 3.0, 3.0, 6.0]&#125;.
     * Parallel prefix computation is usually more efficient than
     * sequential loops for large arrays.
     *
     * &lt;p&gt; Because floating-point operations may not be strictly associative,
     * the returned result may not be identical to the value that would be
     * obtained if the operation was performed sequentially.
     *
     * @param array the array, which is modified in-place by this method
     * @param op a side-effect-free function to perform the cumulation
     * @throws NullPointerException if the specified array or function is null
     * @since 1.8
     */
    public static void parallelPrefix(double[] array, DoubleBinaryOperator op) &#123;
        Objects.requireNonNull(op);
        if (array.length &gt; 0)
            new ArrayPrefixHelpers.DoubleCumulateTask
                    (null, op, array, 0, array.length).invoke();
    &#125;

    /**
     * Performs &#123;@link #parallelPrefix(double[], DoubleBinaryOperator)&#125;
     * for the given subrange of the array.
     *
     * @param array the array
     * @param fromIndex the index of the first element, inclusive
     * @param toIndex the index of the last element, exclusive
     * @param op a side-effect-free, associative function to perform the
     * cumulation
     * @throws IllegalArgumentException if &#123;@code fromIndex &gt; toIndex&#125;
     * @throws ArrayIndexOutOfBoundsException
     *     if &#123;@code fromIndex &lt; 0&#125; or &#123;@code toIndex &gt; array.length&#125;
     * @throws NullPointerException if the specified array or function is null
     * @since 1.8
     */
    public static void parallelPrefix(double[] array, int fromIndex,
                                      int toIndex, DoubleBinaryOperator op) &#123;
        Objects.requireNonNull(op);
        rangeCheck(array.length, fromIndex, toIndex);
        if (fromIndex &lt; toIndex)
            new ArrayPrefixHelpers.DoubleCumulateTask
                    (null, op, array, fromIndex, toIndex).invoke();
    &#125;

    /**
     * Cumulates, in parallel, each element of the given array in place,
     * using the supplied function. For example if the array initially
     * holds &#123;@code [2, 1, 0, 3]&#125; and the operation performs addition,
     * then upon return the array holds &#123;@code [2, 3, 3, 6]&#125;.
     * Parallel prefix computation is usually more efficient than
     * sequential loops for large arrays.
     *
     * @param array the array, which is modified in-place by this method
     * @param op a side-effect-free, associative function to perform the
     * cumulation
     * @throws NullPointerException if the specified array or function is null
     * @since 1.8
     */
    public static void parallelPrefix(int[] array, IntBinaryOperator op) &#123;
        Objects.requireNonNull(op);
        if (array.length &gt; 0)
            new ArrayPrefixHelpers.IntCumulateTask
                    (null, op, array, 0, array.length).invoke();
    &#125;

    /**
     * Performs &#123;@link #parallelPrefix(int[], IntBinaryOperator)&#125;
     * for the given subrange of the array.
     *
     * @param array the array
     * @param fromIndex the index of the first element, inclusive
     * @param toIndex the index of the last element, exclusive
     * @param op a side-effect-free, associative function to perform the
     * cumulation
     * @throws IllegalArgumentException if &#123;@code fromIndex &gt; toIndex&#125;
     * @throws ArrayIndexOutOfBoundsException
     *     if &#123;@code fromIndex &lt; 0&#125; or &#123;@code toIndex &gt; array.length&#125;
     * @throws NullPointerException if the specified array or function is null
     * @since 1.8
     */
    public static void parallelPrefix(int[] array, int fromIndex,
                                      int toIndex, IntBinaryOperator op) &#123;
        Objects.requireNonNull(op);
        rangeCheck(array.length, fromIndex, toIndex);
        if (fromIndex &lt; toIndex)
            new ArrayPrefixHelpers.IntCumulateTask
                    (null, op, array, fromIndex, toIndex).invoke();
    &#125;

    // Searching

    /**
     * Searches the specified array of longs for the specified value using the
     * binary search algorithm.  The array must be sorted (as
     * by the &#123;@link #sort(long[])&#125; method) prior to making this call.  If it
     * is not sorted, the results are undefined.  If the array contains
     * multiple elements with the specified value, there is no guarantee which
     * one will be found.
     *
     * @param a the array to be searched
     * @param key the value to be searched for
     * @return index of the search key, if it is contained in the array;
     *         otherwise, &lt;tt&gt;(-(&lt;i&gt;insertion point&lt;/i&gt;) - 1)&lt;/tt&gt;.  The
     *         &lt;i&gt;insertion point&lt;/i&gt; is defined as the point at which the
     *         key would be inserted into the array: the index of the first
     *         element greater than the key, or &lt;tt&gt;a.length&lt;/tt&gt; if all
     *         elements in the array are less than the specified key.  Note
     *         that this guarantees that the return value will be &amp;gt;= 0 if
     *         and only if the key is found.
     */
    public static int binarySearch(long[] a, long key) &#123;
        return binarySearch0(a, 0, a.length, key);
    &#125;

    /**
     * Searches a range of
     * the specified array of longs for the specified value using the
     * binary search algorithm.
     * The range must be sorted (as
     * by the &#123;@link #sort(long[], int, int)&#125; method)
     * prior to making this call.  If it
     * is not sorted, the results are undefined.  If the range contains
     * multiple elements with the specified value, there is no guarantee which
     * one will be found.
     *
     * @param a the array to be searched
     * @param fromIndex the index of the first element (inclusive) to be
     *          searched
     * @param toIndex the index of the last element (exclusive) to be searched
     * @param key the value to be searched for
     * @return index of the search key, if it is contained in the array
     *         within the specified range;
     *         otherwise, &lt;tt&gt;(-(&lt;i&gt;insertion point&lt;/i&gt;) - 1)&lt;/tt&gt;.  The
     *         &lt;i&gt;insertion point&lt;/i&gt; is defined as the point at which the
     *         key would be inserted into the array: the index of the first
     *         element in the range greater than the key,
     *         or &lt;tt&gt;toIndex&lt;/tt&gt; if all
     *         elements in the range are less than the specified key.  Note
     *         that this guarantees that the return value will be &amp;gt;= 0 if
     *         and only if the key is found.
     * @throws IllegalArgumentException
     *         if &#123;@code fromIndex &gt; toIndex&#125;
     * @throws ArrayIndexOutOfBoundsException
     *         if &#123;@code fromIndex &lt; 0 or toIndex &gt; a.length&#125;
     * @since 1.6
     */
    public static int binarySearch(long[] a, int fromIndex, int toIndex,
                                   long key) &#123;
        rangeCheck(a.length, fromIndex, toIndex);
        return binarySearch0(a, fromIndex, toIndex, key);
    &#125;

    // Like public version, but without range checks.
    private static int binarySearch0(long[] a, int fromIndex, int toIndex,
                                     long key) &#123;
        int low = fromIndex;
        int high = toIndex - 1;

        while (low &lt;= high) &#123;
            int mid = (low + high) &gt;&gt;&gt; 1;
            long midVal = a[mid];

            if (midVal &lt; key)
                low = mid + 1;
            else if (midVal &gt; key)
                high = mid - 1;
            else
                return mid; // key found
        &#125;
        return -(low + 1);  // key not found.
    &#125;

    /**
     * Searches the specified array of ints for the specified value using the
     * binary search algorithm.  The array must be sorted (as
     * by the &#123;@link #sort(int[])&#125; method) prior to making this call.  If it
     * is not sorted, the results are undefined.  If the array contains
     * multiple elements with the specified value, there is no guarantee which
     * one will be found.
     *
     * @param a the array to be searched
     * @param key the value to be searched for
     * @return index of the search key, if it is contained in the array;
     *         otherwise, &lt;tt&gt;(-(&lt;i&gt;insertion point&lt;/i&gt;) - 1)&lt;/tt&gt;.  The
     *         &lt;i&gt;insertion point&lt;/i&gt; is defined as the point at which the
     *         key would be inserted into the array: the index of the first
     *         element greater than the key, or &lt;tt&gt;a.length&lt;/tt&gt; if all
     *         elements in the array are less than the specified key.  Note
     *         that this guarantees that the return value will be &amp;gt;= 0 if
     *         and only if the key is found.
     */
    public static int binarySearch(int[] a, int key) &#123;
        return binarySearch0(a, 0, a.length, key);
    &#125;

    /**
     * Searches a range of
     * the specified array of ints for the specified value using the
     * binary search algorithm.
     * The range must be sorted (as
     * by the &#123;@link #sort(int[], int, int)&#125; method)
     * prior to making this call.  If it
     * is not sorted, the results are undefined.  If the range contains
     * multiple elements with the specified value, there is no guarantee which
     * one will be found.
     *
     * @param a the array to be searched
     * @param fromIndex the index of the first element (inclusive) to be
     *          searched
     * @param toIndex the index of the last element (exclusive) to be searched
     * @param key the value to be searched for
     * @return index of the search key, if it is contained in the array
     *         within the specified range;
     *         otherwise, &lt;tt&gt;(-(&lt;i&gt;insertion point&lt;/i&gt;) - 1)&lt;/tt&gt;.  The
     *         &lt;i&gt;insertion point&lt;/i&gt; is defined as the point at which the
     *         key would be inserted into the array: the index of the first
     *         element in the range greater than the key,
     *         or &lt;tt&gt;toIndex&lt;/tt&gt; if all
     *         elements in the range are less than the specified key.  Note
     *         that this guarantees that the return value will be &amp;gt;= 0 if
     *         and only if the key is found.
     * @throws IllegalArgumentException
     *         if &#123;@code fromIndex &gt; toIndex&#125;
     * @throws ArrayIndexOutOfBoundsException
     *         if &#123;@code fromIndex &lt; 0 or toIndex &gt; a.length&#125;
     * @since 1.6
     */
    public static int binarySearch(int[] a, int fromIndex, int toIndex,
                                   int key) &#123;
        rangeCheck(a.length, fromIndex, toIndex);
        return binarySearch0(a, fromIndex, toIndex, key);
    &#125;

    // Like public version, but without range checks.
    private static int binarySearch0(int[] a, int fromIndex, int toIndex,
                                     int key) &#123;
        int low = fromIndex;
        int high = toIndex - 1;

        while (low &lt;= high) &#123;
            int mid = (low + high) &gt;&gt;&gt; 1;
            int midVal = a[mid];

            if (midVal &lt; key)
                low = mid + 1;
            else if (midVal &gt; key)
                high = mid - 1;
            else
                return mid; // key found
        &#125;
        return -(low + 1);  // key not found.
    &#125;

    /**
     * Searches the specified array of shorts for the specified value using
     * the binary search algorithm.  The array must be sorted
     * (as by the &#123;@link #sort(short[])&#125; method) prior to making this call.  If
     * it is not sorted, the results are undefined.  If the array contains
     * multiple elements with the specified value, there is no guarantee which
     * one will be found.
     *
     * @param a the array to be searched
     * @param key the value to be searched for
     * @return index of the search key, if it is contained in the array;
     *         otherwise, &lt;tt&gt;(-(&lt;i&gt;insertion point&lt;/i&gt;) - 1)&lt;/tt&gt;.  The
     *         &lt;i&gt;insertion point&lt;/i&gt; is defined as the point at which the
     *         key would be inserted into the array: the index of the first
     *         element greater than the key, or &lt;tt&gt;a.length&lt;/tt&gt; if all
     *         elements in the array are less than the specified key.  Note
     *         that this guarantees that the return value will be &amp;gt;= 0 if
     *         and only if the key is found.
     */
    public static int binarySearch(short[] a, short key) &#123;
        return binarySearch0(a, 0, a.length, key);
    &#125;

    /**
     * Searches a range of
     * the specified array of shorts for the specified value using
     * the binary search algorithm.
     * The range must be sorted
     * (as by the &#123;@link #sort(short[], int, int)&#125; method)
     * prior to making this call.  If
     * it is not sorted, the results are undefined.  If the range contains
     * multiple elements with the specified value, there is no guarantee which
     * one will be found.
     *
     * @param a the array to be searched
     * @param fromIndex the index of the first element (inclusive) to be
     *          searched
     * @param toIndex the index of the last element (exclusive) to be searched
     * @param key the value to be searched for
     * @return index of the search key, if it is contained in the array
     *         within the specified range;
     *         otherwise, &lt;tt&gt;(-(&lt;i&gt;insertion point&lt;/i&gt;) - 1)&lt;/tt&gt;.  The
     *         &lt;i&gt;insertion point&lt;/i&gt; is defined as the point at which the
     *         key would be inserted into the array: the index of the first
     *         element in the range greater than the key,
     *         or &lt;tt&gt;toIndex&lt;/tt&gt; if all
     *         elements in the range are less than the specified key.  Note
     *         that this guarantees that the return value will be &amp;gt;= 0 if
     *         and only if the key is found.
     * @throws IllegalArgumentException
     *         if &#123;@code fromIndex &gt; toIndex&#125;
     * @throws ArrayIndexOutOfBoundsException
     *         if &#123;@code fromIndex &lt; 0 or toIndex &gt; a.length&#125;
     * @since 1.6
     */
    public static int binarySearch(short[] a, int fromIndex, int toIndex,
                                   short key) &#123;
        rangeCheck(a.length, fromIndex, toIndex);
        return binarySearch0(a, fromIndex, toIndex, key);
    &#125;

    // Like public version, but without range checks.
    private static int binarySearch0(short[] a, int fromIndex, int toIndex,
                                     short key) &#123;
        int low = fromIndex;
        int high = toIndex - 1;

        while (low &lt;= high) &#123;
            int mid = (low + high) &gt;&gt;&gt; 1;
            short midVal = a[mid];

            if (midVal &lt; key)
                low = mid + 1;
            else if (midVal &gt; key)
                high = mid - 1;
            else
                return mid; // key found
        &#125;
        return -(low + 1);  // key not found.
    &#125;

    /**
     * Searches the specified array of chars for the specified value using the
     * binary search algorithm.  The array must be sorted (as
     * by the &#123;@link #sort(char[])&#125; method) prior to making this call.  If it
     * is not sorted, the results are undefined.  If the array contains
     * multiple elements with the specified value, there is no guarantee which
     * one will be found.
     *
     * @param a the array to be searched
     * @param key the value to be searched for
     * @return index of the search key, if it is contained in the array;
     *         otherwise, &lt;tt&gt;(-(&lt;i&gt;insertion point&lt;/i&gt;) - 1)&lt;/tt&gt;.  The
     *         &lt;i&gt;insertion point&lt;/i&gt; is defined as the point at which the
     *         key would be inserted into the array: the index of the first
     *         element greater than the key, or &lt;tt&gt;a.length&lt;/tt&gt; if all
     *         elements in the array are less than the specified key.  Note
     *         that this guarantees that the return value will be &amp;gt;= 0 if
     *         and only if the key is found.
     */
    public static int binarySearch(char[] a, char key) &#123;
        return binarySearch0(a, 0, a.length, key);
    &#125;

    /**
     * Searches a range of
     * the specified array of chars for the specified value using the
     * binary search algorithm.
     * The range must be sorted (as
     * by the &#123;@link #sort(char[], int, int)&#125; method)
     * prior to making this call.  If it
     * is not sorted, the results are undefined.  If the range contains
     * multiple elements with the specified value, there is no guarantee which
     * one will be found.
     *
     * @param a the array to be searched
     * @param fromIndex the index of the first element (inclusive) to be
     *          searched
     * @param toIndex the index of the last element (exclusive) to be searched
     * @param key the value to be searched for
     * @return index of the search key, if it is contained in the array
     *         within the specified range;
     *         otherwise, &lt;tt&gt;(-(&lt;i&gt;insertion point&lt;/i&gt;) - 1)&lt;/tt&gt;.  The
     *         &lt;i&gt;insertion point&lt;/i&gt; is defined as the point at which the
     *         key would be inserted into the array: the index of the first
     *         element in the range greater than the key,
     *         or &lt;tt&gt;toIndex&lt;/tt&gt; if all
     *         elements in the range are less than the specified key.  Note
     *         that this guarantees that the return value will be &amp;gt;= 0 if
     *         and only if the key is found.
     * @throws IllegalArgumentException
     *         if &#123;@code fromIndex &gt; toIndex&#125;
     * @throws ArrayIndexOutOfBoundsException
     *         if &#123;@code fromIndex &lt; 0 or toIndex &gt; a.length&#125;
     * @since 1.6
     */
    public static int binarySearch(char[] a, int fromIndex, int toIndex,
                                   char key) &#123;
        rangeCheck(a.length, fromIndex, toIndex);
        return binarySearch0(a, fromIndex, toIndex, key);
    &#125;

    // Like public version, but without range checks.
    private static int binarySearch0(char[] a, int fromIndex, int toIndex,
                                     char key) &#123;
        int low = fromIndex;
        int high = toIndex - 1;

        while (low &lt;= high) &#123;
            int mid = (low + high) &gt;&gt;&gt; 1;
            char midVal = a[mid];

            if (midVal &lt; key)
                low = mid + 1;
            else if (midVal &gt; key)
                high = mid - 1;
            else
                return mid; // key found
        &#125;
        return -(low + 1);  // key not found.
    &#125;

    /**
     * Searches the specified array of bytes for the specified value using the
     * binary search algorithm.  The array must be sorted (as
     * by the &#123;@link #sort(byte[])&#125; method) prior to making this call.  If it
     * is not sorted, the results are undefined.  If the array contains
     * multiple elements with the specified value, there is no guarantee which
     * one will be found.
     *
     * @param a the array to be searched
     * @param key the value to be searched for
     * @return index of the search key, if it is contained in the array;
     *         otherwise, &lt;tt&gt;(-(&lt;i&gt;insertion point&lt;/i&gt;) - 1)&lt;/tt&gt;.  The
     *         &lt;i&gt;insertion point&lt;/i&gt; is defined as the point at which the
     *         key would be inserted into the array: the index of the first
     *         element greater than the key, or &lt;tt&gt;a.length&lt;/tt&gt; if all
     *         elements in the array are less than the specified key.  Note
     *         that this guarantees that the return value will be &amp;gt;= 0 if
     *         and only if the key is found.
     */
    public static int binarySearch(byte[] a, byte key) &#123;
        return binarySearch0(a, 0, a.length, key);
    &#125;

    /**
     * Searches a range of
     * the specified array of bytes for the specified value using the
     * binary search algorithm.
     * The range must be sorted (as
     * by the &#123;@link #sort(byte[], int, int)&#125; method)
     * prior to making this call.  If it
     * is not sorted, the results are undefined.  If the range contains
     * multiple elements with the specified value, there is no guarantee which
     * one will be found.
     *
     * @param a the array to be searched
     * @param fromIndex the index of the first element (inclusive) to be
     *          searched
     * @param toIndex the index of the last element (exclusive) to be searched
     * @param key the value to be searched for
     * @return index of the search key, if it is contained in the array
     *         within the specified range;
     *         otherwise, &lt;tt&gt;(-(&lt;i&gt;insertion point&lt;/i&gt;) - 1)&lt;/tt&gt;.  The
     *         &lt;i&gt;insertion point&lt;/i&gt; is defined as the point at which the
     *         key would be inserted into the array: the index of the first
     *         element in the range greater than the key,
     *         or &lt;tt&gt;toIndex&lt;/tt&gt; if all
     *         elements in the range are less than the specified key.  Note
     *         that this guarantees that the return value will be &amp;gt;= 0 if
     *         and only if the key is found.
     * @throws IllegalArgumentException
     *         if &#123;@code fromIndex &gt; toIndex&#125;
     * @throws ArrayIndexOutOfBoundsException
     *         if &#123;@code fromIndex &lt; 0 or toIndex &gt; a.length&#125;
     * @since 1.6
     */
    public static int binarySearch(byte[] a, int fromIndex, int toIndex,
                                   byte key) &#123;
        rangeCheck(a.length, fromIndex, toIndex);
        return binarySearch0(a, fromIndex, toIndex, key);
    &#125;

    // Like public version, but without range checks.
    private static int binarySearch0(byte[] a, int fromIndex, int toIndex,
                                     byte key) &#123;
        int low = fromIndex;
        int high = toIndex - 1;

        while (low &lt;= high) &#123;
            int mid = (low + high) &gt;&gt;&gt; 1;
            byte midVal = a[mid];

            if (midVal &lt; key)
                low = mid + 1;
            else if (midVal &gt; key)
                high = mid - 1;
            else
                return mid; // key found
        &#125;
        return -(low + 1);  // key not found.
    &#125;

    /**
     * Searches the specified array of doubles for the specified value using
     * the binary search algorithm.  The array must be sorted
     * (as by the &#123;@link #sort(double[])&#125; method) prior to making this call.
     * If it is not sorted, the results are undefined.  If the array contains
     * multiple elements with the specified value, there is no guarantee which
     * one will be found.  This method considers all NaN values to be
     * equivalent and equal.
     *
     * @param a the array to be searched
     * @param key the value to be searched for
     * @return index of the search key, if it is contained in the array;
     *         otherwise, &lt;tt&gt;(-(&lt;i&gt;insertion point&lt;/i&gt;) - 1)&lt;/tt&gt;.  The
     *         &lt;i&gt;insertion point&lt;/i&gt; is defined as the point at which the
     *         key would be inserted into the array: the index of the first
     *         element greater than the key, or &lt;tt&gt;a.length&lt;/tt&gt; if all
     *         elements in the array are less than the specified key.  Note
     *         that this guarantees that the return value will be &amp;gt;= 0 if
     *         and only if the key is found.
     */
    public static int binarySearch(double[] a, double key) &#123;
        return binarySearch0(a, 0, a.length, key);
    &#125;

    /**
     * Searches a range of
     * the specified array of doubles for the specified value using
     * the binary search algorithm.
     * The range must be sorted
     * (as by the &#123;@link #sort(double[], int, int)&#125; method)
     * prior to making this call.
     * If it is not sorted, the results are undefined.  If the range contains
     * multiple elements with the specified value, there is no guarantee which
     * one will be found.  This method considers all NaN values to be
     * equivalent and equal.
     *
     * @param a the array to be searched
     * @param fromIndex the index of the first element (inclusive) to be
     *          searched
     * @param toIndex the index of the last element (exclusive) to be searched
     * @param key the value to be searched for
     * @return index of the search key, if it is contained in the array
     *         within the specified range;
     *         otherwise, &lt;tt&gt;(-(&lt;i&gt;insertion point&lt;/i&gt;) - 1)&lt;/tt&gt;.  The
     *         &lt;i&gt;insertion point&lt;/i&gt; is defined as the point at which the
     *         key would be inserted into the array: the index of the first
     *         element in the range greater than the key,
     *         or &lt;tt&gt;toIndex&lt;/tt&gt; if all
     *         elements in the range are less than the specified key.  Note
     *         that this guarantees that the return value will be &amp;gt;= 0 if
     *         and only if the key is found.
     * @throws IllegalArgumentException
     *         if &#123;@code fromIndex &gt; toIndex&#125;
     * @throws ArrayIndexOutOfBoundsException
     *         if &#123;@code fromIndex &lt; 0 or toIndex &gt; a.length&#125;
     * @since 1.6
     */
    public static int binarySearch(double[] a, int fromIndex, int toIndex,
                                   double key) &#123;
        rangeCheck(a.length, fromIndex, toIndex);
        return binarySearch0(a, fromIndex, toIndex, key);
    &#125;

    // Like public version, but without range checks.
    private static int binarySearch0(double[] a, int fromIndex, int toIndex,
                                     double key) &#123;
        int low = fromIndex;
        int high = toIndex - 1;

        while (low &lt;= high) &#123;
            int mid = (low + high) &gt;&gt;&gt; 1;
            double midVal = a[mid];

            if (midVal &lt; key)
                low = mid + 1;  // Neither val is NaN, thisVal is smaller
            else if (midVal &gt; key)
                high = mid - 1; // Neither val is NaN, thisVal is larger
            else &#123;
                long midBits = Double.doubleToLongBits(midVal);
                long keyBits = Double.doubleToLongBits(key);
                if (midBits == keyBits)     // Values are equal
                    return mid;             // Key found
                else if (midBits &lt; keyBits) // (-0.0, 0.0) or (!NaN, NaN)
                    low = mid + 1;
                else                        // (0.0, -0.0) or (NaN, !NaN)
                    high = mid - 1;
            &#125;
        &#125;
        return -(low + 1);  // key not found.
    &#125;

    /**
     * Searches the specified array of floats for the specified value using
     * the binary search algorithm. The array must be sorted
     * (as by the &#123;@link #sort(float[])&#125; method) prior to making this call. If
     * it is not sorted, the results are undefined. If the array contains
     * multiple elements with the specified value, there is no guarantee which
     * one will be found. This method considers all NaN values to be
     * equivalent and equal.
     *
     * @param a the array to be searched
     * @param key the value to be searched for
     * @return index of the search key, if it is contained in the array;
     *         otherwise, &lt;tt&gt;(-(&lt;i&gt;insertion point&lt;/i&gt;) - 1)&lt;/tt&gt;. The
     *         &lt;i&gt;insertion point&lt;/i&gt; is defined as the point at which the
     *         key would be inserted into the array: the index of the first
     *         element greater than the key, or &lt;tt&gt;a.length&lt;/tt&gt; if all
     *         elements in the array are less than the specified key. Note
     *         that this guarantees that the return value will be &amp;gt;= 0 if
     *         and only if the key is found.
     */
    public static int binarySearch(float[] a, float key) &#123;
        return binarySearch0(a, 0, a.length, key);
    &#125;

    /**
     * Searches a range of
     * the specified array of floats for the specified value using
     * the binary search algorithm.
     * The range must be sorted
     * (as by the &#123;@link #sort(float[], int, int)&#125; method)
     * prior to making this call. If
     * it is not sorted, the results are undefined. If the range contains
     * multiple elements with the specified value, there is no guarantee which
     * one will be found. This method considers all NaN values to be
     * equivalent and equal.
     *
     * @param a the array to be searched
     * @param fromIndex the index of the first element (inclusive) to be
     *          searched
     * @param toIndex the index of the last element (exclusive) to be searched
     * @param key the value to be searched for
     * @return index of the search key, if it is contained in the array
     *         within the specified range;
     *         otherwise, &lt;tt&gt;(-(&lt;i&gt;insertion point&lt;/i&gt;) - 1)&lt;/tt&gt;. The
     *         &lt;i&gt;insertion point&lt;/i&gt; is defined as the point at which the
     *         key would be inserted into the array: the index of the first
     *         element in the range greater than the key,
     *         or &lt;tt&gt;toIndex&lt;/tt&gt; if all
     *         elements in the range are less than the specified key. Note
     *         that this guarantees that the return value will be &amp;gt;= 0 if
     *         and only if the key is found.
     * @throws IllegalArgumentException
     *         if &#123;@code fromIndex &gt; toIndex&#125;
     * @throws ArrayIndexOutOfBoundsException
     *         if &#123;@code fromIndex &lt; 0 or toIndex &gt; a.length&#125;
     * @since 1.6
     */
    public static int binarySearch(float[] a, int fromIndex, int toIndex,
                                   float key) &#123;
        rangeCheck(a.length, fromIndex, toIndex);
        return binarySearch0(a, fromIndex, toIndex, key);
    &#125;

    // Like public version, but without range checks.
    private static int binarySearch0(float[] a, int fromIndex, int toIndex,
                                     float key) &#123;
        int low = fromIndex;
        int high = toIndex - 1;

        while (low &lt;= high) &#123;
            int mid = (low + high) &gt;&gt;&gt; 1;
            float midVal = a[mid];

            if (midVal &lt; key)
                low = mid + 1;  // Neither val is NaN, thisVal is smaller
            else if (midVal &gt; key)
                high = mid - 1; // Neither val is NaN, thisVal is larger
            else &#123;
                int midBits = Float.floatToIntBits(midVal);
                int keyBits = Float.floatToIntBits(key);
                if (midBits == keyBits)     // Values are equal
                    return mid;             // Key found
                else if (midBits &lt; keyBits) // (-0.0, 0.0) or (!NaN, NaN)
                    low = mid + 1;
                else                        // (0.0, -0.0) or (NaN, !NaN)
                    high = mid - 1;
            &#125;
        &#125;
        return -(low + 1);  // key not found.
    &#125;

    /**
     * Searches the specified array for the specified object using the binary
     * search algorithm. The array must be sorted into ascending order
     * according to the
     * &#123;@linkplain Comparable natural ordering&#125;
     * of its elements (as by the
     * &#123;@link #sort(Object[])&#125; method) prior to making this call.
     * If it is not sorted, the results are undefined.
     * (If the array contains elements that are not mutually comparable (for
     * example, strings and integers), it &lt;i&gt;cannot&lt;/i&gt; be sorted according
     * to the natural ordering of its elements, hence results are undefined.)
     * If the array contains multiple
     * elements equal to the specified object, there is no guarantee which
     * one will be found.
     *
     * @param a the array to be searched
     * @param key the value to be searched for
     * @return index of the search key, if it is contained in the array;
     *         otherwise, &lt;tt&gt;(-(&lt;i&gt;insertion point&lt;/i&gt;) - 1)&lt;/tt&gt;.  The
     *         &lt;i&gt;insertion point&lt;/i&gt; is defined as the point at which the
     *         key would be inserted into the array: the index of the first
     *         element greater than the key, or &lt;tt&gt;a.length&lt;/tt&gt; if all
     *         elements in the array are less than the specified key.  Note
     *         that this guarantees that the return value will be &amp;gt;= 0 if
     *         and only if the key is found.
     * @throws ClassCastException if the search key is not comparable to the
     *         elements of the array.
     */
    public static int binarySearch(Object[] a, Object key) &#123;
        return binarySearch0(a, 0, a.length, key);
    &#125;

    /**
     * Searches a range of
     * the specified array for the specified object using the binary
     * search algorithm.
     * The range must be sorted into ascending order
     * according to the
     * &#123;@linkplain Comparable natural ordering&#125;
     * of its elements (as by the
     * &#123;@link #sort(Object[], int, int)&#125; method) prior to making this
     * call.  If it is not sorted, the results are undefined.
     * (If the range contains elements that are not mutually comparable (for
     * example, strings and integers), it &lt;i&gt;cannot&lt;/i&gt; be sorted according
     * to the natural ordering of its elements, hence results are undefined.)
     * If the range contains multiple
     * elements equal to the specified object, there is no guarantee which
     * one will be found.
     *
     * @param a the array to be searched
     * @param fromIndex the index of the first element (inclusive) to be
     *          searched
     * @param toIndex the index of the last element (exclusive) to be searched
     * @param key the value to be searched for
     * @return index of the search key, if it is contained in the array
     *         within the specified range;
     *         otherwise, &lt;tt&gt;(-(&lt;i&gt;insertion point&lt;/i&gt;) - 1)&lt;/tt&gt;.  The
     *         &lt;i&gt;insertion point&lt;/i&gt; is defined as the point at which the
     *         key would be inserted into the array: the index of the first
     *         element in the range greater than the key,
     *         or &lt;tt&gt;toIndex&lt;/tt&gt; if all
     *         elements in the range are less than the specified key.  Note
     *         that this guarantees that the return value will be &amp;gt;= 0 if
     *         and only if the key is found.
     * @throws ClassCastException if the search key is not comparable to the
     *         elements of the array within the specified range.
     * @throws IllegalArgumentException
     *         if &#123;@code fromIndex &gt; toIndex&#125;
     * @throws ArrayIndexOutOfBoundsException
     *         if &#123;@code fromIndex &lt; 0 or toIndex &gt; a.length&#125;
     * @since 1.6
     */
    public static int binarySearch(Object[] a, int fromIndex, int toIndex,
                                   Object key) &#123;
        rangeCheck(a.length, fromIndex, toIndex);
        return binarySearch0(a, fromIndex, toIndex, key);
    &#125;

    // Like public version, but without range checks.
    private static int binarySearch0(Object[] a, int fromIndex, int toIndex,
                                     Object key) &#123;
        int low = fromIndex;
        int high = toIndex - 1;

        while (low &lt;= high) &#123;
            int mid = (low + high) &gt;&gt;&gt; 1;
            @SuppressWarnings(&quot;rawtypes&quot;)
            Comparable midVal = (Comparable)a[mid];
            @SuppressWarnings(&quot;unchecked&quot;)
            int cmp = midVal.compareTo(key);

            if (cmp &lt; 0)
                low = mid + 1;
            else if (cmp &gt; 0)
                high = mid - 1;
            else
                return mid; // key found
        &#125;
        return -(low + 1);  // key not found.
    &#125;

    /**
     * Searches the specified array for the specified object using the binary
     * search algorithm.  The array must be sorted into ascending order
     * according to the specified comparator (as by the
     * &#123;@link #sort(Object[], Comparator) sort(T[], Comparator)&#125;
     * method) prior to making this call.  If it is
     * not sorted, the results are undefined.
     * If the array contains multiple
     * elements equal to the specified object, there is no guarantee which one
     * will be found.
     *
     * @param &lt;T&gt; the class of the objects in the array
     * @param a the array to be searched
     * @param key the value to be searched for
     * @param c the comparator by which the array is ordered.  A
     *        &lt;tt&gt;null&lt;/tt&gt; value indicates that the elements&#39;
     *        &#123;@linkplain Comparable natural ordering&#125; should be used.
     * @return index of the search key, if it is contained in the array;
     *         otherwise, &lt;tt&gt;(-(&lt;i&gt;insertion point&lt;/i&gt;) - 1)&lt;/tt&gt;.  The
     *         &lt;i&gt;insertion point&lt;/i&gt; is defined as the point at which the
     *         key would be inserted into the array: the index of the first
     *         element greater than the key, or &lt;tt&gt;a.length&lt;/tt&gt; if all
     *         elements in the array are less than the specified key.  Note
     *         that this guarantees that the return value will be &amp;gt;= 0 if
     *         and only if the key is found.
     * @throws ClassCastException if the array contains elements that are not
     *         &lt;i&gt;mutually comparable&lt;/i&gt; using the specified comparator,
     *         or the search key is not comparable to the
     *         elements of the array using this comparator.
     */
    public static &lt;T&gt; int binarySearch(T[] a, T key, Comparator&lt;? super T&gt; c) &#123;
        return binarySearch0(a, 0, a.length, key, c);
    &#125;

    /**
     * Searches a range of
     * the specified array for the specified object using the binary
     * search algorithm.
     * The range must be sorted into ascending order
     * according to the specified comparator (as by the
     * &#123;@link #sort(Object[], int, int, Comparator)
     * sort(T[], int, int, Comparator)&#125;
     * method) prior to making this call.
     * If it is not sorted, the results are undefined.
     * If the range contains multiple elements equal to the specified object,
     * there is no guarantee which one will be found.
     *
     * @param &lt;T&gt; the class of the objects in the array
     * @param a the array to be searched
     * @param fromIndex the index of the first element (inclusive) to be
     *          searched
     * @param toIndex the index of the last element (exclusive) to be searched
     * @param key the value to be searched for
     * @param c the comparator by which the array is ordered.  A
     *        &lt;tt&gt;null&lt;/tt&gt; value indicates that the elements&#39;
     *        &#123;@linkplain Comparable natural ordering&#125; should be used.
     * @return index of the search key, if it is contained in the array
     *         within the specified range;
     *         otherwise, &lt;tt&gt;(-(&lt;i&gt;insertion point&lt;/i&gt;) - 1)&lt;/tt&gt;.  The
     *         &lt;i&gt;insertion point&lt;/i&gt; is defined as the point at which the
     *         key would be inserted into the array: the index of the first
     *         element in the range greater than the key,
     *         or &lt;tt&gt;toIndex&lt;/tt&gt; if all
     *         elements in the range are less than the specified key.  Note
     *         that this guarantees that the return value will be &amp;gt;= 0 if
     *         and only if the key is found.
     * @throws ClassCastException if the range contains elements that are not
     *         &lt;i&gt;mutually comparable&lt;/i&gt; using the specified comparator,
     *         or the search key is not comparable to the
     *         elements in the range using this comparator.
     * @throws IllegalArgumentException
     *         if &#123;@code fromIndex &gt; toIndex&#125;
     * @throws ArrayIndexOutOfBoundsException
     *         if &#123;@code fromIndex &lt; 0 or toIndex &gt; a.length&#125;
     * @since 1.6
     */
    public static &lt;T&gt; int binarySearch(T[] a, int fromIndex, int toIndex,
                                       T key, Comparator&lt;? super T&gt; c) &#123;
        rangeCheck(a.length, fromIndex, toIndex);
        return binarySearch0(a, fromIndex, toIndex, key, c);
    &#125;

    // Like public version, but without range checks.
    private static &lt;T&gt; int binarySearch0(T[] a, int fromIndex, int toIndex,
                                         T key, Comparator&lt;? super T&gt; c) &#123;
        if (c == null) &#123;
            return binarySearch0(a, fromIndex, toIndex, key);
        &#125;
        int low = fromIndex;
        int high = toIndex - 1;

        while (low &lt;= high) &#123;
            int mid = (low + high) &gt;&gt;&gt; 1;
            T midVal = a[mid];
            int cmp = c.compare(midVal, key);
            if (cmp &lt; 0)
                low = mid + 1;
            else if (cmp &gt; 0)
                high = mid - 1;
            else
                return mid; // key found
        &#125;
        return -(low + 1);  // key not found.
    &#125;

    // Equality Testing

    /**
     * Returns &lt;tt&gt;true&lt;/tt&gt; if the two specified arrays of longs are
     * &lt;i&gt;equal&lt;/i&gt; to one another.  Two arrays are considered equal if both
     * arrays contain the same number of elements, and all corresponding pairs
     * of elements in the two arrays are equal.  In other words, two arrays
     * are equal if they contain the same elements in the same order.  Also,
     * two array references are considered equal if both are &lt;tt&gt;null&lt;/tt&gt;.&lt;p&gt;
     *
     * @param a one array to be tested for equality
     * @param a2 the other array to be tested for equality
     * @return &lt;tt&gt;true&lt;/tt&gt; if the two arrays are equal
     */
    public static boolean equals(long[] a, long[] a2) &#123;
        if (a==a2)
            return true;
        if (a==null || a2==null)
            return false;

        int length = a.length;
        if (a2.length != length)
            return false;

        for (int i=0; i&lt;length; i++)
            if (a[i] != a2[i])
                return false;

        return true;
    &#125;

    /**
     * Returns &lt;tt&gt;true&lt;/tt&gt; if the two specified arrays of ints are
     * &lt;i&gt;equal&lt;/i&gt; to one another.  Two arrays are considered equal if both
     * arrays contain the same number of elements, and all corresponding pairs
     * of elements in the two arrays are equal.  In other words, two arrays
     * are equal if they contain the same elements in the same order.  Also,
     * two array references are considered equal if both are &lt;tt&gt;null&lt;/tt&gt;.&lt;p&gt;
     *
     * @param a one array to be tested for equality
     * @param a2 the other array to be tested for equality
     * @return &lt;tt&gt;true&lt;/tt&gt; if the two arrays are equal
     */
    public static boolean equals(int[] a, int[] a2) &#123;
        if (a==a2)
            return true;
        if (a==null || a2==null)
            return false;

        int length = a.length;
        if (a2.length != length)
            return false;

        for (int i=0; i&lt;length; i++)
            if (a[i] != a2[i])
                return false;

        return true;
    &#125;

    /**
     * Returns &lt;tt&gt;true&lt;/tt&gt; if the two specified arrays of shorts are
     * &lt;i&gt;equal&lt;/i&gt; to one another.  Two arrays are considered equal if both
     * arrays contain the same number of elements, and all corresponding pairs
     * of elements in the two arrays are equal.  In other words, two arrays
     * are equal if they contain the same elements in the same order.  Also,
     * two array references are considered equal if both are &lt;tt&gt;null&lt;/tt&gt;.&lt;p&gt;
     *
     * @param a one array to be tested for equality
     * @param a2 the other array to be tested for equality
     * @return &lt;tt&gt;true&lt;/tt&gt; if the two arrays are equal
     */
    public static boolean equals(short[] a, short a2[]) &#123;
        if (a==a2)
            return true;
        if (a==null || a2==null)
            return false;

        int length = a.length;
        if (a2.length != length)
            return false;

        for (int i=0; i&lt;length; i++)
            if (a[i] != a2[i])
                return false;

        return true;
    &#125;

    /**
     * Returns &lt;tt&gt;true&lt;/tt&gt; if the two specified arrays of chars are
     * &lt;i&gt;equal&lt;/i&gt; to one another.  Two arrays are considered equal if both
     * arrays contain the same number of elements, and all corresponding pairs
     * of elements in the two arrays are equal.  In other words, two arrays
     * are equal if they contain the same elements in the same order.  Also,
     * two array references are considered equal if both are &lt;tt&gt;null&lt;/tt&gt;.&lt;p&gt;
     *
     * @param a one array to be tested for equality
     * @param a2 the other array to be tested for equality
     * @return &lt;tt&gt;true&lt;/tt&gt; if the two arrays are equal
     */
    public static boolean equals(char[] a, char[] a2) &#123;
        if (a==a2)
            return true;
        if (a==null || a2==null)
            return false;

        int length = a.length;
        if (a2.length != length)
            return false;

        for (int i=0; i&lt;length; i++)
            if (a[i] != a2[i])
                return false;

        return true;
    &#125;

    /**
     * Returns &lt;tt&gt;true&lt;/tt&gt; if the two specified arrays of bytes are
     * &lt;i&gt;equal&lt;/i&gt; to one another.  Two arrays are considered equal if both
     * arrays contain the same number of elements, and all corresponding pairs
     * of elements in the two arrays are equal.  In other words, two arrays
     * are equal if they contain the same elements in the same order.  Also,
     * two array references are considered equal if both are &lt;tt&gt;null&lt;/tt&gt;.&lt;p&gt;
     *
     * @param a one array to be tested for equality
     * @param a2 the other array to be tested for equality
     * @return &lt;tt&gt;true&lt;/tt&gt; if the two arrays are equal
     */
    public static boolean equals(byte[] a, byte[] a2) &#123;
        if (a==a2)
            return true;
        if (a==null || a2==null)
            return false;

        int length = a.length;
        if (a2.length != length)
            return false;

        for (int i=0; i&lt;length; i++)
            if (a[i] != a2[i])
                return false;

        return true;
    &#125;

    /**
     * Returns &lt;tt&gt;true&lt;/tt&gt; if the two specified arrays of booleans are
     * &lt;i&gt;equal&lt;/i&gt; to one another.  Two arrays are considered equal if both
     * arrays contain the same number of elements, and all corresponding pairs
     * of elements in the two arrays are equal.  In other words, two arrays
     * are equal if they contain the same elements in the same order.  Also,
     * two array references are considered equal if both are &lt;tt&gt;null&lt;/tt&gt;.&lt;p&gt;
     *
     * @param a one array to be tested for equality
     * @param a2 the other array to be tested for equality
     * @return &lt;tt&gt;true&lt;/tt&gt; if the two arrays are equal
     */
    public static boolean equals(boolean[] a, boolean[] a2) &#123;
        if (a==a2)
            return true;
        if (a==null || a2==null)
            return false;

        int length = a.length;
        if (a2.length != length)
            return false;

        for (int i=0; i&lt;length; i++)
            if (a[i] != a2[i])
                return false;

        return true;
    &#125;

    /**
     * Returns &lt;tt&gt;true&lt;/tt&gt; if the two specified arrays of doubles are
     * &lt;i&gt;equal&lt;/i&gt; to one another.  Two arrays are considered equal if both
     * arrays contain the same number of elements, and all corresponding pairs
     * of elements in the two arrays are equal.  In other words, two arrays
     * are equal if they contain the same elements in the same order.  Also,
     * two array references are considered equal if both are &lt;tt&gt;null&lt;/tt&gt;.&lt;p&gt;
     *
     * Two doubles &lt;tt&gt;d1&lt;/tt&gt; and &lt;tt&gt;d2&lt;/tt&gt; are considered equal if:
     * &lt;pre&gt;    &lt;tt&gt;new Double(d1).equals(new Double(d2))&lt;/tt&gt;&lt;/pre&gt;
     * (Unlike the &lt;tt&gt;==&lt;/tt&gt; operator, this method considers
     * &lt;tt&gt;NaN&lt;/tt&gt; equals to itself, and 0.0d unequal to -0.0d.)
     *
     * @param a one array to be tested for equality
     * @param a2 the other array to be tested for equality
     * @return &lt;tt&gt;true&lt;/tt&gt; if the two arrays are equal
     * @see Double#equals(Object)
     */
    public static boolean equals(double[] a, double[] a2) &#123;
        if (a==a2)
            return true;
        if (a==null || a2==null)
            return false;

        int length = a.length;
        if (a2.length != length)
            return false;

        for (int i=0; i&lt;length; i++)
            if (Double.doubleToLongBits(a[i])!=Double.doubleToLongBits(a2[i]))
                return false;

        return true;
    &#125;

    /**
     * Returns &lt;tt&gt;true&lt;/tt&gt; if the two specified arrays of floats are
     * &lt;i&gt;equal&lt;/i&gt; to one another.  Two arrays are considered equal if both
     * arrays contain the same number of elements, and all corresponding pairs
     * of elements in the two arrays are equal.  In other words, two arrays
     * are equal if they contain the same elements in the same order.  Also,
     * two array references are considered equal if both are &lt;tt&gt;null&lt;/tt&gt;.&lt;p&gt;
     *
     * Two floats &lt;tt&gt;f1&lt;/tt&gt; and &lt;tt&gt;f2&lt;/tt&gt; are considered equal if:
     * &lt;pre&gt;    &lt;tt&gt;new Float(f1).equals(new Float(f2))&lt;/tt&gt;&lt;/pre&gt;
     * (Unlike the &lt;tt&gt;==&lt;/tt&gt; operator, this method considers
     * &lt;tt&gt;NaN&lt;/tt&gt; equals to itself, and 0.0f unequal to -0.0f.)
     *
     * @param a one array to be tested for equality
     * @param a2 the other array to be tested for equality
     * @return &lt;tt&gt;true&lt;/tt&gt; if the two arrays are equal
     * @see Float#equals(Object)
     */
    public static boolean equals(float[] a, float[] a2) &#123;
        if (a==a2)
            return true;
        if (a==null || a2==null)
            return false;

        int length = a.length;
        if (a2.length != length)
            return false;

        for (int i=0; i&lt;length; i++)
            if (Float.floatToIntBits(a[i])!=Float.floatToIntBits(a2[i]))
                return false;

        return true;
    &#125;

    /**
     * Returns &lt;tt&gt;true&lt;/tt&gt; if the two specified arrays of Objects are
     * &lt;i&gt;equal&lt;/i&gt; to one another.  The two arrays are considered equal if
     * both arrays contain the same number of elements, and all corresponding
     * pairs of elements in the two arrays are equal.  Two objects &lt;tt&gt;e1&lt;/tt&gt;
     * and &lt;tt&gt;e2&lt;/tt&gt; are considered &lt;i&gt;equal&lt;/i&gt; if &lt;tt&gt;(e1==null ? e2==null
     * : e1.equals(e2))&lt;/tt&gt;.  In other words, the two arrays are equal if
     * they contain the same elements in the same order.  Also, two array
     * references are considered equal if both are &lt;tt&gt;null&lt;/tt&gt;.&lt;p&gt;
     *
     * @param a one array to be tested for equality
     * @param a2 the other array to be tested for equality
     * @return &lt;tt&gt;true&lt;/tt&gt; if the two arrays are equal
     */
    public static boolean equals(Object[] a, Object[] a2) &#123;
        if (a==a2)
            return true;
        if (a==null || a2==null)
            return false;

        int length = a.length;
        if (a2.length != length)
            return false;

        for (int i=0; i&lt;length; i++) &#123;
            Object o1 = a[i];
            Object o2 = a2[i];
            if (!(o1==null ? o2==null : o1.equals(o2)))
                return false;
        &#125;

        return true;
    &#125;

    // Filling

    /**
     * Assigns the specified long value to each element of the specified array
     * of longs.
     *
     * @param a the array to be filled
     * @param val the value to be stored in all elements of the array
     */
    public static void fill(long[] a, long val) &#123;
        for (int i = 0, len = a.length; i &lt; len; i++)
            a[i] = val;
    &#125;

    /**
     * Assigns the specified long value to each element of the specified
     * range of the specified array of longs.  The range to be filled
     * extends from index &lt;tt&gt;fromIndex&lt;/tt&gt;, inclusive, to index
     * &lt;tt&gt;toIndex&lt;/tt&gt;, exclusive.  (If &lt;tt&gt;fromIndex==toIndex&lt;/tt&gt;, the
     * range to be filled is empty.)
     *
     * @param a the array to be filled
     * @param fromIndex the index of the first element (inclusive) to be
     *        filled with the specified value
     * @param toIndex the index of the last element (exclusive) to be
     *        filled with the specified value
     * @param val the value to be stored in all elements of the array
     * @throws IllegalArgumentException if &lt;tt&gt;fromIndex &amp;gt; toIndex&lt;/tt&gt;
     * @throws ArrayIndexOutOfBoundsException if &lt;tt&gt;fromIndex &amp;lt; 0&lt;/tt&gt; or
     *         &lt;tt&gt;toIndex &amp;gt; a.length&lt;/tt&gt;
     */
    public static void fill(long[] a, int fromIndex, int toIndex, long val) &#123;
        rangeCheck(a.length, fromIndex, toIndex);
        for (int i = fromIndex; i &lt; toIndex; i++)
            a[i] = val;
    &#125;

    /**
     * Assigns the specified int value to each element of the specified array
     * of ints.
     *
     * @param a the array to be filled
     * @param val the value to be stored in all elements of the array
     */
    public static void fill(int[] a, int val) &#123;
        for (int i = 0, len = a.length; i &lt; len; i++)
            a[i] = val;
    &#125;

    /**
     * Assigns the specified int value to each element of the specified
     * range of the specified array of ints.  The range to be filled
     * extends from index &lt;tt&gt;fromIndex&lt;/tt&gt;, inclusive, to index
     * &lt;tt&gt;toIndex&lt;/tt&gt;, exclusive.  (If &lt;tt&gt;fromIndex==toIndex&lt;/tt&gt;, the
     * range to be filled is empty.)
     *
     * @param a the array to be filled
     * @param fromIndex the index of the first element (inclusive) to be
     *        filled with the specified value
     * @param toIndex the index of the last element (exclusive) to be
     *        filled with the specified value
     * @param val the value to be stored in all elements of the array
     * @throws IllegalArgumentException if &lt;tt&gt;fromIndex &amp;gt; toIndex&lt;/tt&gt;
     * @throws ArrayIndexOutOfBoundsException if &lt;tt&gt;fromIndex &amp;lt; 0&lt;/tt&gt; or
     *         &lt;tt&gt;toIndex &amp;gt; a.length&lt;/tt&gt;
     */
    public static void fill(int[] a, int fromIndex, int toIndex, int val) &#123;
        rangeCheck(a.length, fromIndex, toIndex);
        for (int i = fromIndex; i &lt; toIndex; i++)
            a[i] = val;
    &#125;

    /**
     * Assigns the specified short value to each element of the specified array
     * of shorts.
     *
     * @param a the array to be filled
     * @param val the value to be stored in all elements of the array
     */
    public static void fill(short[] a, short val) &#123;
        for (int i = 0, len = a.length; i &lt; len; i++)
            a[i] = val;
    &#125;

    /**
     * Assigns the specified short value to each element of the specified
     * range of the specified array of shorts.  The range to be filled
     * extends from index &lt;tt&gt;fromIndex&lt;/tt&gt;, inclusive, to index
     * &lt;tt&gt;toIndex&lt;/tt&gt;, exclusive.  (If &lt;tt&gt;fromIndex==toIndex&lt;/tt&gt;, the
     * range to be filled is empty.)
     *
     * @param a the array to be filled
     * @param fromIndex the index of the first element (inclusive) to be
     *        filled with the specified value
     * @param toIndex the index of the last element (exclusive) to be
     *        filled with the specified value
     * @param val the value to be stored in all elements of the array
     * @throws IllegalArgumentException if &lt;tt&gt;fromIndex &amp;gt; toIndex&lt;/tt&gt;
     * @throws ArrayIndexOutOfBoundsException if &lt;tt&gt;fromIndex &amp;lt; 0&lt;/tt&gt; or
     *         &lt;tt&gt;toIndex &amp;gt; a.length&lt;/tt&gt;
     */
    public static void fill(short[] a, int fromIndex, int toIndex, short val) &#123;
        rangeCheck(a.length, fromIndex, toIndex);
        for (int i = fromIndex; i &lt; toIndex; i++)
            a[i] = val;
    &#125;

    /**
     * Assigns the specified char value to each element of the specified array
     * of chars.
     *
     * @param a the array to be filled
     * @param val the value to be stored in all elements of the array
     */
    public static void fill(char[] a, char val) &#123;
        for (int i = 0, len = a.length; i &lt; len; i++)
            a[i] = val;
    &#125;

    /**
     * Assigns the specified char value to each element of the specified
     * range of the specified array of chars.  The range to be filled
     * extends from index &lt;tt&gt;fromIndex&lt;/tt&gt;, inclusive, to index
     * &lt;tt&gt;toIndex&lt;/tt&gt;, exclusive.  (If &lt;tt&gt;fromIndex==toIndex&lt;/tt&gt;, the
     * range to be filled is empty.)
     *
     * @param a the array to be filled
     * @param fromIndex the index of the first element (inclusive) to be
     *        filled with the specified value
     * @param toIndex the index of the last element (exclusive) to be
     *        filled with the specified value
     * @param val the value to be stored in all elements of the array
     * @throws IllegalArgumentException if &lt;tt&gt;fromIndex &amp;gt; toIndex&lt;/tt&gt;
     * @throws ArrayIndexOutOfBoundsException if &lt;tt&gt;fromIndex &amp;lt; 0&lt;/tt&gt; or
     *         &lt;tt&gt;toIndex &amp;gt; a.length&lt;/tt&gt;
     */
    public static void fill(char[] a, int fromIndex, int toIndex, char val) &#123;
        rangeCheck(a.length, fromIndex, toIndex);
        for (int i = fromIndex; i &lt; toIndex; i++)
            a[i] = val;
    &#125;

    /**
     * Assigns the specified byte value to each element of the specified array
     * of bytes.
     *
     * @param a the array to be filled
     * @param val the value to be stored in all elements of the array
     */
    public static void fill(byte[] a, byte val) &#123;
        for (int i = 0, len = a.length; i &lt; len; i++)
            a[i] = val;
    &#125;

    /**
     * Assigns the specified byte value to each element of the specified
     * range of the specified array of bytes.  The range to be filled
     * extends from index &lt;tt&gt;fromIndex&lt;/tt&gt;, inclusive, to index
     * &lt;tt&gt;toIndex&lt;/tt&gt;, exclusive.  (If &lt;tt&gt;fromIndex==toIndex&lt;/tt&gt;, the
     * range to be filled is empty.)
     *
     * @param a the array to be filled
     * @param fromIndex the index of the first element (inclusive) to be
     *        filled with the specified value
     * @param toIndex the index of the last element (exclusive) to be
     *        filled with the specified value
     * @param val the value to be stored in all elements of the array
     * @throws IllegalArgumentException if &lt;tt&gt;fromIndex &amp;gt; toIndex&lt;/tt&gt;
     * @throws ArrayIndexOutOfBoundsException if &lt;tt&gt;fromIndex &amp;lt; 0&lt;/tt&gt; or
     *         &lt;tt&gt;toIndex &amp;gt; a.length&lt;/tt&gt;
     */
    public static void fill(byte[] a, int fromIndex, int toIndex, byte val) &#123;
        rangeCheck(a.length, fromIndex, toIndex);
        for (int i = fromIndex; i &lt; toIndex; i++)
            a[i] = val;
    &#125;

    /**
     * Assigns the specified boolean value to each element of the specified
     * array of booleans.
     *
     * @param a the array to be filled
     * @param val the value to be stored in all elements of the array
     */
    public static void fill(boolean[] a, boolean val) &#123;
        for (int i = 0, len = a.length; i &lt; len; i++)
            a[i] = val;
    &#125;

    /**
     * Assigns the specified boolean value to each element of the specified
     * range of the specified array of booleans.  The range to be filled
     * extends from index &lt;tt&gt;fromIndex&lt;/tt&gt;, inclusive, to index
     * &lt;tt&gt;toIndex&lt;/tt&gt;, exclusive.  (If &lt;tt&gt;fromIndex==toIndex&lt;/tt&gt;, the
     * range to be filled is empty.)
     *
     * @param a the array to be filled
     * @param fromIndex the index of the first element (inclusive) to be
     *        filled with the specified value
     * @param toIndex the index of the last element (exclusive) to be
     *        filled with the specified value
     * @param val the value to be stored in all elements of the array
     * @throws IllegalArgumentException if &lt;tt&gt;fromIndex &amp;gt; toIndex&lt;/tt&gt;
     * @throws ArrayIndexOutOfBoundsException if &lt;tt&gt;fromIndex &amp;lt; 0&lt;/tt&gt; or
     *         &lt;tt&gt;toIndex &amp;gt; a.length&lt;/tt&gt;
     */
    public static void fill(boolean[] a, int fromIndex, int toIndex,
                            boolean val) &#123;
        rangeCheck(a.length, fromIndex, toIndex);
        for (int i = fromIndex; i &lt; toIndex; i++)
            a[i] = val;
    &#125;

    /**
     * Assigns the specified double value to each element of the specified
     * array of doubles.
     *
     * @param a the array to be filled
     * @param val the value to be stored in all elements of the array
     */
    public static void fill(double[] a, double val) &#123;
        for (int i = 0, len = a.length; i &lt; len; i++)
            a[i] = val;
    &#125;

    /**
     * Assigns the specified double value to each element of the specified
     * range of the specified array of doubles.  The range to be filled
     * extends from index &lt;tt&gt;fromIndex&lt;/tt&gt;, inclusive, to index
     * &lt;tt&gt;toIndex&lt;/tt&gt;, exclusive.  (If &lt;tt&gt;fromIndex==toIndex&lt;/tt&gt;, the
     * range to be filled is empty.)
     *
     * @param a the array to be filled
     * @param fromIndex the index of the first element (inclusive) to be
     *        filled with the specified value
     * @param toIndex the index of the last element (exclusive) to be
     *        filled with the specified value
     * @param val the value to be stored in all elements of the array
     * @throws IllegalArgumentException if &lt;tt&gt;fromIndex &amp;gt; toIndex&lt;/tt&gt;
     * @throws ArrayIndexOutOfBoundsException if &lt;tt&gt;fromIndex &amp;lt; 0&lt;/tt&gt; or
     *         &lt;tt&gt;toIndex &amp;gt; a.length&lt;/tt&gt;
     */
    public static void fill(double[] a, int fromIndex, int toIndex,double val)&#123;
        rangeCheck(a.length, fromIndex, toIndex);
        for (int i = fromIndex; i &lt; toIndex; i++)
            a[i] = val;
    &#125;

    /**
     * Assigns the specified float value to each element of the specified array
     * of floats.
     *
     * @param a the array to be filled
     * @param val the value to be stored in all elements of the array
     */
    public static void fill(float[] a, float val) &#123;
        for (int i = 0, len = a.length; i &lt; len; i++)
            a[i] = val;
    &#125;

    /**
     * Assigns the specified float value to each element of the specified
     * range of the specified array of floats.  The range to be filled
     * extends from index &lt;tt&gt;fromIndex&lt;/tt&gt;, inclusive, to index
     * &lt;tt&gt;toIndex&lt;/tt&gt;, exclusive.  (If &lt;tt&gt;fromIndex==toIndex&lt;/tt&gt;, the
     * range to be filled is empty.)
     *
     * @param a the array to be filled
     * @param fromIndex the index of the first element (inclusive) to be
     *        filled with the specified value
     * @param toIndex the index of the last element (exclusive) to be
     *        filled with the specified value
     * @param val the value to be stored in all elements of the array
     * @throws IllegalArgumentException if &lt;tt&gt;fromIndex &amp;gt; toIndex&lt;/tt&gt;
     * @throws ArrayIndexOutOfBoundsException if &lt;tt&gt;fromIndex &amp;lt; 0&lt;/tt&gt; or
     *         &lt;tt&gt;toIndex &amp;gt; a.length&lt;/tt&gt;
     */
    public static void fill(float[] a, int fromIndex, int toIndex, float val) &#123;
        rangeCheck(a.length, fromIndex, toIndex);
        for (int i = fromIndex; i &lt; toIndex; i++)
            a[i] = val;
    &#125;

    /**
     * Assigns the specified Object reference to each element of the specified
     * array of Objects.
     *
     * @param a the array to be filled
     * @param val the value to be stored in all elements of the array
     * @throws ArrayStoreException if the specified value is not of a
     *         runtime type that can be stored in the specified array
     */
    public static void fill(Object[] a, Object val) &#123;
        for (int i = 0, len = a.length; i &lt; len; i++)
            a[i] = val;
    &#125;

    /**
     * Assigns the specified Object reference to each element of the specified
     * range of the specified array of Objects.  The range to be filled
     * extends from index &lt;tt&gt;fromIndex&lt;/tt&gt;, inclusive, to index
     * &lt;tt&gt;toIndex&lt;/tt&gt;, exclusive.  (If &lt;tt&gt;fromIndex==toIndex&lt;/tt&gt;, the
     * range to be filled is empty.)
     *
     * @param a the array to be filled
     * @param fromIndex the index of the first element (inclusive) to be
     *        filled with the specified value
     * @param toIndex the index of the last element (exclusive) to be
     *        filled with the specified value
     * @param val the value to be stored in all elements of the array
     * @throws IllegalArgumentException if &lt;tt&gt;fromIndex &amp;gt; toIndex&lt;/tt&gt;
     * @throws ArrayIndexOutOfBoundsException if &lt;tt&gt;fromIndex &amp;lt; 0&lt;/tt&gt; or
     *         &lt;tt&gt;toIndex &amp;gt; a.length&lt;/tt&gt;
     * @throws ArrayStoreException if the specified value is not of a
     *         runtime type that can be stored in the specified array
     */
    public static void fill(Object[] a, int fromIndex, int toIndex, Object val) &#123;
        rangeCheck(a.length, fromIndex, toIndex);
        for (int i = fromIndex; i &lt; toIndex; i++)
            a[i] = val;
    &#125;

    // Cloning

    /**
     * Copies the specified array, truncating or padding with nulls (if necessary)
     * so the copy has the specified length.  For all indices that are
     * valid in both the original array and the copy, the two arrays will
     * contain identical values.  For any indices that are valid in the
     * copy but not the original, the copy will contain &lt;tt&gt;null&lt;/tt&gt;.
     * Such indices will exist if and only if the specified length
     * is greater than that of the original array.
     * The resulting array is of exactly the same class as the original array.
     *
     * @param &lt;T&gt; the class of the objects in the array
     * @param original the array to be copied
     * @param newLength the length of the copy to be returned
     * @return a copy of the original array, truncated or padded with nulls
     *     to obtain the specified length
     * @throws NegativeArraySizeException if &lt;tt&gt;newLength&lt;/tt&gt; is negative
     * @throws NullPointerException if &lt;tt&gt;original&lt;/tt&gt; is null
     * @since 1.6
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;T&gt; T[] copyOf(T[] original, int newLength) &#123;
        return (T[]) copyOf(original, newLength, original.getClass());
    &#125;

    /**
     * Copies the specified array, truncating or padding with nulls (if necessary)
     * so the copy has the specified length.  For all indices that are
     * valid in both the original array and the copy, the two arrays will
     * contain identical values.  For any indices that are valid in the
     * copy but not the original, the copy will contain &lt;tt&gt;null&lt;/tt&gt;.
     * Such indices will exist if and only if the specified length
     * is greater than that of the original array.
     * The resulting array is of the class &lt;tt&gt;newType&lt;/tt&gt;.
     *
     * @param &lt;U&gt; the class of the objects in the original array
     * @param &lt;T&gt; the class of the objects in the returned array
     * @param original the array to be copied
     * @param newLength the length of the copy to be returned
     * @param newType the class of the copy to be returned
     * @return a copy of the original array, truncated or padded with nulls
     *     to obtain the specified length
     * @throws NegativeArraySizeException if &lt;tt&gt;newLength&lt;/tt&gt; is negative
     * @throws NullPointerException if &lt;tt&gt;original&lt;/tt&gt; is null
     * @throws ArrayStoreException if an element copied from
     *     &lt;tt&gt;original&lt;/tt&gt; is not of a runtime type that can be stored in
     *     an array of class &lt;tt&gt;newType&lt;/tt&gt;
     * @since 1.6
     */
    public static &lt;T,U&gt; T[] copyOf(U[] original, int newLength, Class&lt;? extends T[]&gt; newType) &#123;
        @SuppressWarnings(&quot;unchecked&quot;)
        T[] copy = ((Object)newType == (Object)Object[].class)
            ? (T[]) new Object[newLength]
            : (T[]) Array.newInstance(newType.getComponentType(), newLength);
        System.arraycopy(original, 0, copy, 0,
                         Math.min(original.length, newLength));
        return copy;
    &#125;

    /**
     * Copies the specified array, truncating or padding with zeros (if necessary)
     * so the copy has the specified length.  For all indices that are
     * valid in both the original array and the copy, the two arrays will
     * contain identical values.  For any indices that are valid in the
     * copy but not the original, the copy will contain &lt;tt&gt;(byte)0&lt;/tt&gt;.
     * Such indices will exist if and only if the specified length
     * is greater than that of the original array.
     *
     * @param original the array to be copied
     * @param newLength the length of the copy to be returned
     * @return a copy of the original array, truncated or padded with zeros
     *     to obtain the specified length
     * @throws NegativeArraySizeException if &lt;tt&gt;newLength&lt;/tt&gt; is negative
     * @throws NullPointerException if &lt;tt&gt;original&lt;/tt&gt; is null
     * @since 1.6
     */
    public static byte[] copyOf(byte[] original, int newLength) &#123;
        byte[] copy = new byte[newLength];
        System.arraycopy(original, 0, copy, 0,
                         Math.min(original.length, newLength));
        return copy;
    &#125;

    /**
     * Copies the specified array, truncating or padding with zeros (if necessary)
     * so the copy has the specified length.  For all indices that are
     * valid in both the original array and the copy, the two arrays will
     * contain identical values.  For any indices that are valid in the
     * copy but not the original, the copy will contain &lt;tt&gt;(short)0&lt;/tt&gt;.
     * Such indices will exist if and only if the specified length
     * is greater than that of the original array.
     *
     * @param original the array to be copied
     * @param newLength the length of the copy to be returned
     * @return a copy of the original array, truncated or padded with zeros
     *     to obtain the specified length
     * @throws NegativeArraySizeException if &lt;tt&gt;newLength&lt;/tt&gt; is negative
     * @throws NullPointerException if &lt;tt&gt;original&lt;/tt&gt; is null
     * @since 1.6
     */
    public static short[] copyOf(short[] original, int newLength) &#123;
        short[] copy = new short[newLength];
        System.arraycopy(original, 0, copy, 0,
                         Math.min(original.length, newLength));
        return copy;
    &#125;

    /**
     * Copies the specified array, truncating or padding with zeros (if necessary)
     * so the copy has the specified length.  For all indices that are
     * valid in both the original array and the copy, the two arrays will
     * contain identical values.  For any indices that are valid in the
     * copy but not the original, the copy will contain &lt;tt&gt;0&lt;/tt&gt;.
     * Such indices will exist if and only if the specified length
     * is greater than that of the original array.
     *
     * @param original the array to be copied
     * @param newLength the length of the copy to be returned
     * @return a copy of the original array, truncated or padded with zeros
     *     to obtain the specified length
     * @throws NegativeArraySizeException if &lt;tt&gt;newLength&lt;/tt&gt; is negative
     * @throws NullPointerException if &lt;tt&gt;original&lt;/tt&gt; is null
     * @since 1.6
     */
    public static int[] copyOf(int[] original, int newLength) &#123;
        int[] copy = new int[newLength];
        System.arraycopy(original, 0, copy, 0,
                         Math.min(original.length, newLength));
        return copy;
    &#125;

    /**
     * Copies the specified array, truncating or padding with zeros (if necessary)
     * so the copy has the specified length.  For all indices that are
     * valid in both the original array and the copy, the two arrays will
     * contain identical values.  For any indices that are valid in the
     * copy but not the original, the copy will contain &lt;tt&gt;0L&lt;/tt&gt;.
     * Such indices will exist if and only if the specified length
     * is greater than that of the original array.
     *
     * @param original the array to be copied
     * @param newLength the length of the copy to be returned
     * @return a copy of the original array, truncated or padded with zeros
     *     to obtain the specified length
     * @throws NegativeArraySizeException if &lt;tt&gt;newLength&lt;/tt&gt; is negative
     * @throws NullPointerException if &lt;tt&gt;original&lt;/tt&gt; is null
     * @since 1.6
     */
    public static long[] copyOf(long[] original, int newLength) &#123;
        long[] copy = new long[newLength];
        System.arraycopy(original, 0, copy, 0,
                         Math.min(original.length, newLength));
        return copy;
    &#125;

    /**
     * Copies the specified array, truncating or padding with null characters (if necessary)
     * so the copy has the specified length.  For all indices that are valid
     * in both the original array and the copy, the two arrays will contain
     * identical values.  For any indices that are valid in the copy but not
     * the original, the copy will contain &lt;tt&gt;&#39;\\u000&#39;&lt;/tt&gt;.  Such indices
     * will exist if and only if the specified length is greater than that of
     * the original array.
     *
     * @param original the array to be copied
     * @param newLength the length of the copy to be returned
     * @return a copy of the original array, truncated or padded with null characters
     *     to obtain the specified length
     * @throws NegativeArraySizeException if &lt;tt&gt;newLength&lt;/tt&gt; is negative
     * @throws NullPointerException if &lt;tt&gt;original&lt;/tt&gt; is null
     * @since 1.6
     */
    public static char[] copyOf(char[] original, int newLength) &#123;
        char[] copy = new char[newLength];
        System.arraycopy(original, 0, copy, 0,
                         Math.min(original.length, newLength));
        return copy;
    &#125;

    /**
     * Copies the specified array, truncating or padding with zeros (if necessary)
     * so the copy has the specified length.  For all indices that are
     * valid in both the original array and the copy, the two arrays will
     * contain identical values.  For any indices that are valid in the
     * copy but not the original, the copy will contain &lt;tt&gt;0f&lt;/tt&gt;.
     * Such indices will exist if and only if the specified length
     * is greater than that of the original array.
     *
     * @param original the array to be copied
     * @param newLength the length of the copy to be returned
     * @return a copy of the original array, truncated or padded with zeros
     *     to obtain the specified length
     * @throws NegativeArraySizeException if &lt;tt&gt;newLength&lt;/tt&gt; is negative
     * @throws NullPointerException if &lt;tt&gt;original&lt;/tt&gt; is null
     * @since 1.6
     */
    public static float[] copyOf(float[] original, int newLength) &#123;
        float[] copy = new float[newLength];
        System.arraycopy(original, 0, copy, 0,
                         Math.min(original.length, newLength));
        return copy;
    &#125;

    /**
     * Copies the specified array, truncating or padding with zeros (if necessary)
     * so the copy has the specified length.  For all indices that are
     * valid in both the original array and the copy, the two arrays will
     * contain identical values.  For any indices that are valid in the
     * copy but not the original, the copy will contain &lt;tt&gt;0d&lt;/tt&gt;.
     * Such indices will exist if and only if the specified length
     * is greater than that of the original array.
     *
     * @param original the array to be copied
     * @param newLength the length of the copy to be returned
     * @return a copy of the original array, truncated or padded with zeros
     *     to obtain the specified length
     * @throws NegativeArraySizeException if &lt;tt&gt;newLength&lt;/tt&gt; is negative
     * @throws NullPointerException if &lt;tt&gt;original&lt;/tt&gt; is null
     * @since 1.6
     */
    public static double[] copyOf(double[] original, int newLength) &#123;
        double[] copy = new double[newLength];
        System.arraycopy(original, 0, copy, 0,
                         Math.min(original.length, newLength));
        return copy;
    &#125;

    /**
     * Copies the specified array, truncating or padding with &lt;tt&gt;false&lt;/tt&gt; (if necessary)
     * so the copy has the specified length.  For all indices that are
     * valid in both the original array and the copy, the two arrays will
     * contain identical values.  For any indices that are valid in the
     * copy but not the original, the copy will contain &lt;tt&gt;false&lt;/tt&gt;.
     * Such indices will exist if and only if the specified length
     * is greater than that of the original array.
     *
     * @param original the array to be copied
     * @param newLength the length of the copy to be returned
     * @return a copy of the original array, truncated or padded with false elements
     *     to obtain the specified length
     * @throws NegativeArraySizeException if &lt;tt&gt;newLength&lt;/tt&gt; is negative
     * @throws NullPointerException if &lt;tt&gt;original&lt;/tt&gt; is null
     * @since 1.6
     */
    public static boolean[] copyOf(boolean[] original, int newLength) &#123;
        boolean[] copy = new boolean[newLength];
        System.arraycopy(original, 0, copy, 0,
                         Math.min(original.length, newLength));
        return copy;
    &#125;

    /**
     * Copies the specified range of the specified array into a new array.
     * The initial index of the range (&lt;tt&gt;from&lt;/tt&gt;) must lie between zero
     * and &lt;tt&gt;original.length&lt;/tt&gt;, inclusive.  The value at
     * &lt;tt&gt;original[from]&lt;/tt&gt; is placed into the initial element of the copy
     * (unless &lt;tt&gt;from == original.length&lt;/tt&gt; or &lt;tt&gt;from == to&lt;/tt&gt;).
     * Values from subsequent elements in the original array are placed into
     * subsequent elements in the copy.  The final index of the range
     * (&lt;tt&gt;to&lt;/tt&gt;), which must be greater than or equal to &lt;tt&gt;from&lt;/tt&gt;,
     * may be greater than &lt;tt&gt;original.length&lt;/tt&gt;, in which case
     * &lt;tt&gt;null&lt;/tt&gt; is placed in all elements of the copy whose index is
     * greater than or equal to &lt;tt&gt;original.length - from&lt;/tt&gt;.  The length
     * of the returned array will be &lt;tt&gt;to - from&lt;/tt&gt;.
     * &lt;p&gt;
     * The resulting array is of exactly the same class as the original array.
     *
     * @param &lt;T&gt; the class of the objects in the array
     * @param original the array from which a range is to be copied
     * @param from the initial index of the range to be copied, inclusive
     * @param to the final index of the range to be copied, exclusive.
     *     (This index may lie outside the array.)
     * @return a new array containing the specified range from the original array,
     *     truncated or padded with nulls to obtain the required length
     * @throws ArrayIndexOutOfBoundsException if &#123;@code from &lt; 0&#125;
     *     or &#123;@code from &gt; original.length&#125;
     * @throws IllegalArgumentException if &lt;tt&gt;from &amp;gt; to&lt;/tt&gt;
     * @throws NullPointerException if &lt;tt&gt;original&lt;/tt&gt; is null
     * @since 1.6
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;T&gt; T[] copyOfRange(T[] original, int from, int to) &#123;
        return copyOfRange(original, from, to, (Class&lt;? extends T[]&gt;) original.getClass());
    &#125;

    /**
     * Copies the specified range of the specified array into a new array.
     * The initial index of the range (&lt;tt&gt;from&lt;/tt&gt;) must lie between zero
     * and &lt;tt&gt;original.length&lt;/tt&gt;, inclusive.  The value at
     * &lt;tt&gt;original[from]&lt;/tt&gt; is placed into the initial element of the copy
     * (unless &lt;tt&gt;from == original.length&lt;/tt&gt; or &lt;tt&gt;from == to&lt;/tt&gt;).
     * Values from subsequent elements in the original array are placed into
     * subsequent elements in the copy.  The final index of the range
     * (&lt;tt&gt;to&lt;/tt&gt;), which must be greater than or equal to &lt;tt&gt;from&lt;/tt&gt;,
     * may be greater than &lt;tt&gt;original.length&lt;/tt&gt;, in which case
     * &lt;tt&gt;null&lt;/tt&gt; is placed in all elements of the copy whose index is
     * greater than or equal to &lt;tt&gt;original.length - from&lt;/tt&gt;.  The length
     * of the returned array will be &lt;tt&gt;to - from&lt;/tt&gt;.
     * The resulting array is of the class &lt;tt&gt;newType&lt;/tt&gt;.
     *
     * @param &lt;U&gt; the class of the objects in the original array
     * @param &lt;T&gt; the class of the objects in the returned array
     * @param original the array from which a range is to be copied
     * @param from the initial index of the range to be copied, inclusive
     * @param to the final index of the range to be copied, exclusive.
     *     (This index may lie outside the array.)
     * @param newType the class of the copy to be returned
     * @return a new array containing the specified range from the original array,
     *     truncated or padded with nulls to obtain the required length
     * @throws ArrayIndexOutOfBoundsException if &#123;@code from &lt; 0&#125;
     *     or &#123;@code from &gt; original.length&#125;
     * @throws IllegalArgumentException if &lt;tt&gt;from &amp;gt; to&lt;/tt&gt;
     * @throws NullPointerException if &lt;tt&gt;original&lt;/tt&gt; is null
     * @throws ArrayStoreException if an element copied from
     *     &lt;tt&gt;original&lt;/tt&gt; is not of a runtime type that can be stored in
     *     an array of class &lt;tt&gt;newType&lt;/tt&gt;.
     * @since 1.6
     */
    public static &lt;T,U&gt; T[] copyOfRange(U[] original, int from, int to, Class&lt;? extends T[]&gt; newType) &#123;
        int newLength = to - from;
        if (newLength &lt; 0)
            throw new IllegalArgumentException(from + &quot; &gt; &quot; + to);
        @SuppressWarnings(&quot;unchecked&quot;)
        T[] copy = ((Object)newType == (Object)Object[].class)
            ? (T[]) new Object[newLength]
            : (T[]) Array.newInstance(newType.getComponentType(), newLength);
        System.arraycopy(original, from, copy, 0,
                         Math.min(original.length - from, newLength));
        return copy;
    &#125;

    /**
     * Copies the specified range of the specified array into a new array.
     * The initial index of the range (&lt;tt&gt;from&lt;/tt&gt;) must lie between zero
     * and &lt;tt&gt;original.length&lt;/tt&gt;, inclusive.  The value at
     * &lt;tt&gt;original[from]&lt;/tt&gt; is placed into the initial element of the copy
     * (unless &lt;tt&gt;from == original.length&lt;/tt&gt; or &lt;tt&gt;from == to&lt;/tt&gt;).
     * Values from subsequent elements in the original array are placed into
     * subsequent elements in the copy.  The final index of the range
     * (&lt;tt&gt;to&lt;/tt&gt;), which must be greater than or equal to &lt;tt&gt;from&lt;/tt&gt;,
     * may be greater than &lt;tt&gt;original.length&lt;/tt&gt;, in which case
     * &lt;tt&gt;(byte)0&lt;/tt&gt; is placed in all elements of the copy whose index is
     * greater than or equal to &lt;tt&gt;original.length - from&lt;/tt&gt;.  The length
     * of the returned array will be &lt;tt&gt;to - from&lt;/tt&gt;.
     *
     * @param original the array from which a range is to be copied
     * @param from the initial index of the range to be copied, inclusive
     * @param to the final index of the range to be copied, exclusive.
     *     (This index may lie outside the array.)
     * @return a new array containing the specified range from the original array,
     *     truncated or padded with zeros to obtain the required length
     * @throws ArrayIndexOutOfBoundsException if &#123;@code from &lt; 0&#125;
     *     or &#123;@code from &gt; original.length&#125;
     * @throws IllegalArgumentException if &lt;tt&gt;from &amp;gt; to&lt;/tt&gt;
     * @throws NullPointerException if &lt;tt&gt;original&lt;/tt&gt; is null
     * @since 1.6
     */
    public static byte[] copyOfRange(byte[] original, int from, int to) &#123;
        int newLength = to - from;
        if (newLength &lt; 0)
            throw new IllegalArgumentException(from + &quot; &gt; &quot; + to);
        byte[] copy = new byte[newLength];
        System.arraycopy(original, from, copy, 0,
                         Math.min(original.length - from, newLength));
        return copy;
    &#125;

    /**
     * Copies the specified range of the specified array into a new array.
     * The initial index of the range (&lt;tt&gt;from&lt;/tt&gt;) must lie between zero
     * and &lt;tt&gt;original.length&lt;/tt&gt;, inclusive.  The value at
     * &lt;tt&gt;original[from]&lt;/tt&gt; is placed into the initial element of the copy
     * (unless &lt;tt&gt;from == original.length&lt;/tt&gt; or &lt;tt&gt;from == to&lt;/tt&gt;).
     * Values from subsequent elements in the original array are placed into
     * subsequent elements in the copy.  The final index of the range
     * (&lt;tt&gt;to&lt;/tt&gt;), which must be greater than or equal to &lt;tt&gt;from&lt;/tt&gt;,
     * may be greater than &lt;tt&gt;original.length&lt;/tt&gt;, in which case
     * &lt;tt&gt;(short)0&lt;/tt&gt; is placed in all elements of the copy whose index is
     * greater than or equal to &lt;tt&gt;original.length - from&lt;/tt&gt;.  The length
     * of the returned array will be &lt;tt&gt;to - from&lt;/tt&gt;.
     *
     * @param original the array from which a range is to be copied
     * @param from the initial index of the range to be copied, inclusive
     * @param to the final index of the range to be copied, exclusive.
     *     (This index may lie outside the array.)
     * @return a new array containing the specified range from the original array,
     *     truncated or padded with zeros to obtain the required length
     * @throws ArrayIndexOutOfBoundsException if &#123;@code from &lt; 0&#125;
     *     or &#123;@code from &gt; original.length&#125;
     * @throws IllegalArgumentException if &lt;tt&gt;from &amp;gt; to&lt;/tt&gt;
     * @throws NullPointerException if &lt;tt&gt;original&lt;/tt&gt; is null
     * @since 1.6
     */
    public static short[] copyOfRange(short[] original, int from, int to) &#123;
        int newLength = to - from;
        if (newLength &lt; 0)
            throw new IllegalArgumentException(from + &quot; &gt; &quot; + to);
        short[] copy = new short[newLength];
        System.arraycopy(original, from, copy, 0,
                         Math.min(original.length - from, newLength));
        return copy;
    &#125;

    /**
     * Copies the specified range of the specified array into a new array.
     * The initial index of the range (&lt;tt&gt;from&lt;/tt&gt;) must lie between zero
     * and &lt;tt&gt;original.length&lt;/tt&gt;, inclusive.  The value at
     * &lt;tt&gt;original[from]&lt;/tt&gt; is placed into the initial element of the copy
     * (unless &lt;tt&gt;from == original.length&lt;/tt&gt; or &lt;tt&gt;from == to&lt;/tt&gt;).
     * Values from subsequent elements in the original array are placed into
     * subsequent elements in the copy.  The final index of the range
     * (&lt;tt&gt;to&lt;/tt&gt;), which must be greater than or equal to &lt;tt&gt;from&lt;/tt&gt;,
     * may be greater than &lt;tt&gt;original.length&lt;/tt&gt;, in which case
     * &lt;tt&gt;0&lt;/tt&gt; is placed in all elements of the copy whose index is
     * greater than or equal to &lt;tt&gt;original.length - from&lt;/tt&gt;.  The length
     * of the returned array will be &lt;tt&gt;to - from&lt;/tt&gt;.
     *
     * @param original the array from which a range is to be copied
     * @param from the initial index of the range to be copied, inclusive
     * @param to the final index of the range to be copied, exclusive.
     *     (This index may lie outside the array.)
     * @return a new array containing the specified range from the original array,
     *     truncated or padded with zeros to obtain the required length
     * @throws ArrayIndexOutOfBoundsException if &#123;@code from &lt; 0&#125;
     *     or &#123;@code from &gt; original.length&#125;
     * @throws IllegalArgumentException if &lt;tt&gt;from &amp;gt; to&lt;/tt&gt;
     * @throws NullPointerException if &lt;tt&gt;original&lt;/tt&gt; is null
     * @since 1.6
     */
    public static int[] copyOfRange(int[] original, int from, int to) &#123;
        int newLength = to - from;
        if (newLength &lt; 0)
            throw new IllegalArgumentException(from + &quot; &gt; &quot; + to);
        int[] copy = new int[newLength];
        System.arraycopy(original, from, copy, 0,
                         Math.min(original.length - from, newLength));
        return copy;
    &#125;

    /**
     * Copies the specified range of the specified array into a new array.
     * The initial index of the range (&lt;tt&gt;from&lt;/tt&gt;) must lie between zero
     * and &lt;tt&gt;original.length&lt;/tt&gt;, inclusive.  The value at
     * &lt;tt&gt;original[from]&lt;/tt&gt; is placed into the initial element of the copy
     * (unless &lt;tt&gt;from == original.length&lt;/tt&gt; or &lt;tt&gt;from == to&lt;/tt&gt;).
     * Values from subsequent elements in the original array are placed into
     * subsequent elements in the copy.  The final index of the range
     * (&lt;tt&gt;to&lt;/tt&gt;), which must be greater than or equal to &lt;tt&gt;from&lt;/tt&gt;,
     * may be greater than &lt;tt&gt;original.length&lt;/tt&gt;, in which case
     * &lt;tt&gt;0L&lt;/tt&gt; is placed in all elements of the copy whose index is
     * greater than or equal to &lt;tt&gt;original.length - from&lt;/tt&gt;.  The length
     * of the returned array will be &lt;tt&gt;to - from&lt;/tt&gt;.
     *
     * @param original the array from which a range is to be copied
     * @param from the initial index of the range to be copied, inclusive
     * @param to the final index of the range to be copied, exclusive.
     *     (This index may lie outside the array.)
     * @return a new array containing the specified range from the original array,
     *     truncated or padded with zeros to obtain the required length
     * @throws ArrayIndexOutOfBoundsException if &#123;@code from &lt; 0&#125;
     *     or &#123;@code from &gt; original.length&#125;
     * @throws IllegalArgumentException if &lt;tt&gt;from &amp;gt; to&lt;/tt&gt;
     * @throws NullPointerException if &lt;tt&gt;original&lt;/tt&gt; is null
     * @since 1.6
     */
    public static long[] copyOfRange(long[] original, int from, int to) &#123;
        int newLength = to - from;
        if (newLength &lt; 0)
            throw new IllegalArgumentException(from + &quot; &gt; &quot; + to);
        long[] copy = new long[newLength];
        System.arraycopy(original, from, copy, 0,
                         Math.min(original.length - from, newLength));
        return copy;
    &#125;

    /**
     * Copies the specified range of the specified array into a new array.
     * The initial index of the range (&lt;tt&gt;from&lt;/tt&gt;) must lie between zero
     * and &lt;tt&gt;original.length&lt;/tt&gt;, inclusive.  The value at
     * &lt;tt&gt;original[from]&lt;/tt&gt; is placed into the initial element of the copy
     * (unless &lt;tt&gt;from == original.length&lt;/tt&gt; or &lt;tt&gt;from == to&lt;/tt&gt;).
     * Values from subsequent elements in the original array are placed into
     * subsequent elements in the copy.  The final index of the range
     * (&lt;tt&gt;to&lt;/tt&gt;), which must be greater than or equal to &lt;tt&gt;from&lt;/tt&gt;,
     * may be greater than &lt;tt&gt;original.length&lt;/tt&gt;, in which case
     * &lt;tt&gt;&#39;\\u000&#39;&lt;/tt&gt; is placed in all elements of the copy whose index is
     * greater than or equal to &lt;tt&gt;original.length - from&lt;/tt&gt;.  The length
     * of the returned array will be &lt;tt&gt;to - from&lt;/tt&gt;.
     *
     * @param original the array from which a range is to be copied
     * @param from the initial index of the range to be copied, inclusive
     * @param to the final index of the range to be copied, exclusive.
     *     (This index may lie outside the array.)
     * @return a new array containing the specified range from the original array,
     *     truncated or padded with null characters to obtain the required length
     * @throws ArrayIndexOutOfBoundsException if &#123;@code from &lt; 0&#125;
     *     or &#123;@code from &gt; original.length&#125;
     * @throws IllegalArgumentException if &lt;tt&gt;from &amp;gt; to&lt;/tt&gt;
     * @throws NullPointerException if &lt;tt&gt;original&lt;/tt&gt; is null
     * @since 1.6
     */
    public static char[] copyOfRange(char[] original, int from, int to) &#123;
        int newLength = to - from;
        if (newLength &lt; 0)
            throw new IllegalArgumentException(from + &quot; &gt; &quot; + to);
        char[] copy = new char[newLength];
        System.arraycopy(original, from, copy, 0,
                         Math.min(original.length - from, newLength));
        return copy;
    &#125;

    /**
     * Copies the specified range of the specified array into a new array.
     * The initial index of the range (&lt;tt&gt;from&lt;/tt&gt;) must lie between zero
     * and &lt;tt&gt;original.length&lt;/tt&gt;, inclusive.  The value at
     * &lt;tt&gt;original[from]&lt;/tt&gt; is placed into the initial element of the copy
     * (unless &lt;tt&gt;from == original.length&lt;/tt&gt; or &lt;tt&gt;from == to&lt;/tt&gt;).
     * Values from subsequent elements in the original array are placed into
     * subsequent elements in the copy.  The final index of the range
     * (&lt;tt&gt;to&lt;/tt&gt;), which must be greater than or equal to &lt;tt&gt;from&lt;/tt&gt;,
     * may be greater than &lt;tt&gt;original.length&lt;/tt&gt;, in which case
     * &lt;tt&gt;0f&lt;/tt&gt; is placed in all elements of the copy whose index is
     * greater than or equal to &lt;tt&gt;original.length - from&lt;/tt&gt;.  The length
     * of the returned array will be &lt;tt&gt;to - from&lt;/tt&gt;.
     *
     * @param original the array from which a range is to be copied
     * @param from the initial index of the range to be copied, inclusive
     * @param to the final index of the range to be copied, exclusive.
     *     (This index may lie outside the array.)
     * @return a new array containing the specified range from the original array,
     *     truncated or padded with zeros to obtain the required length
     * @throws ArrayIndexOutOfBoundsException if &#123;@code from &lt; 0&#125;
     *     or &#123;@code from &gt; original.length&#125;
     * @throws IllegalArgumentException if &lt;tt&gt;from &amp;gt; to&lt;/tt&gt;
     * @throws NullPointerException if &lt;tt&gt;original&lt;/tt&gt; is null
     * @since 1.6
     */
    public static float[] copyOfRange(float[] original, int from, int to) &#123;
        int newLength = to - from;
        if (newLength &lt; 0)
            throw new IllegalArgumentException(from + &quot; &gt; &quot; + to);
        float[] copy = new float[newLength];
        System.arraycopy(original, from, copy, 0,
                         Math.min(original.length - from, newLength));
        return copy;
    &#125;

    /**
     * Copies the specified range of the specified array into a new array.
     * The initial index of the range (&lt;tt&gt;from&lt;/tt&gt;) must lie between zero
     * and &lt;tt&gt;original.length&lt;/tt&gt;, inclusive.  The value at
     * &lt;tt&gt;original[from]&lt;/tt&gt; is placed into the initial element of the copy
     * (unless &lt;tt&gt;from == original.length&lt;/tt&gt; or &lt;tt&gt;from == to&lt;/tt&gt;).
     * Values from subsequent elements in the original array are placed into
     * subsequent elements in the copy.  The final index of the range
     * (&lt;tt&gt;to&lt;/tt&gt;), which must be greater than or equal to &lt;tt&gt;from&lt;/tt&gt;,
     * may be greater than &lt;tt&gt;original.length&lt;/tt&gt;, in which case
     * &lt;tt&gt;0d&lt;/tt&gt; is placed in all elements of the copy whose index is
     * greater than or equal to &lt;tt&gt;original.length - from&lt;/tt&gt;.  The length
     * of the returned array will be &lt;tt&gt;to - from&lt;/tt&gt;.
     *
     * @param original the array from which a range is to be copied
     * @param from the initial index of the range to be copied, inclusive
     * @param to the final index of the range to be copied, exclusive.
     *     (This index may lie outside the array.)
     * @return a new array containing the specified range from the original array,
     *     truncated or padded with zeros to obtain the required length
     * @throws ArrayIndexOutOfBoundsException if &#123;@code from &lt; 0&#125;
     *     or &#123;@code from &gt; original.length&#125;
     * @throws IllegalArgumentException if &lt;tt&gt;from &amp;gt; to&lt;/tt&gt;
     * @throws NullPointerException if &lt;tt&gt;original&lt;/tt&gt; is null
     * @since 1.6
     */
    public static double[] copyOfRange(double[] original, int from, int to) &#123;
        int newLength = to - from;
        if (newLength &lt; 0)
            throw new IllegalArgumentException(from + &quot; &gt; &quot; + to);
        double[] copy = new double[newLength];
        System.arraycopy(original, from, copy, 0,
                         Math.min(original.length - from, newLength));
        return copy;
    &#125;

    /**
     * Copies the specified range of the specified array into a new array.
     * The initial index of the range (&lt;tt&gt;from&lt;/tt&gt;) must lie between zero
     * and &lt;tt&gt;original.length&lt;/tt&gt;, inclusive.  The value at
     * &lt;tt&gt;original[from]&lt;/tt&gt; is placed into the initial element of the copy
     * (unless &lt;tt&gt;from == original.length&lt;/tt&gt; or &lt;tt&gt;from == to&lt;/tt&gt;).
     * Values from subsequent elements in the original array are placed into
     * subsequent elements in the copy.  The final index of the range
     * (&lt;tt&gt;to&lt;/tt&gt;), which must be greater than or equal to &lt;tt&gt;from&lt;/tt&gt;,
     * may be greater than &lt;tt&gt;original.length&lt;/tt&gt;, in which case
     * &lt;tt&gt;false&lt;/tt&gt; is placed in all elements of the copy whose index is
     * greater than or equal to &lt;tt&gt;original.length - from&lt;/tt&gt;.  The length
     * of the returned array will be &lt;tt&gt;to - from&lt;/tt&gt;.
     *
     * @param original the array from which a range is to be copied
     * @param from the initial index of the range to be copied, inclusive
     * @param to the final index of the range to be copied, exclusive.
     *     (This index may lie outside the array.)
     * @return a new array containing the specified range from the original array,
     *     truncated or padded with false elements to obtain the required length
     * @throws ArrayIndexOutOfBoundsException if &#123;@code from &lt; 0&#125;
     *     or &#123;@code from &gt; original.length&#125;
     * @throws IllegalArgumentException if &lt;tt&gt;from &amp;gt; to&lt;/tt&gt;
     * @throws NullPointerException if &lt;tt&gt;original&lt;/tt&gt; is null
     * @since 1.6
     */
    public static boolean[] copyOfRange(boolean[] original, int from, int to) &#123;
        int newLength = to - from;
        if (newLength &lt; 0)
            throw new IllegalArgumentException(from + &quot; &gt; &quot; + to);
        boolean[] copy = new boolean[newLength];
        System.arraycopy(original, from, copy, 0,
                         Math.min(original.length - from, newLength));
        return copy;
    &#125;

    // Misc

    /**
     * Returns a fixed-size list backed by the specified array.  (Changes to
     * the returned list &quot;write through&quot; to the array.)  This method acts
     * as bridge between array-based and collection-based APIs, in
     * combination with &#123;@link Collection#toArray&#125;.  The returned list is
     * serializable and implements &#123;@link RandomAccess&#125;.
     *
     * &lt;p&gt;This method also provides a convenient way to create a fixed-size
     * list initialized to contain several elements:
     * &lt;pre&gt;
     *     List&amp;lt;String&amp;gt; stooges = Arrays.asList(&quot;Larry&quot;, &quot;Moe&quot;, &quot;Curly&quot;);
     * &lt;/pre&gt;
     *
     * @param &lt;T&gt; the class of the objects in the array
     * @param a the array by which the list will be backed
     * @return a list view of the specified array
     */
    @SafeVarargs
    @SuppressWarnings(&quot;varargs&quot;)
    public static &lt;T&gt; List&lt;T&gt; asList(T... a) &#123;
        return new ArrayList&lt;&gt;(a);
    &#125;

    /**
     * @serial include
     */
    private static class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;
        implements RandomAccess, java.io.Serializable
    &#123;
        private static final long serialVersionUID = -2764017481108945198L;
        private final E[] a;

        ArrayList(E[] array) &#123;
            a = Objects.requireNonNull(array);
        &#125;

        @Override
        public int size() &#123;
            return a.length;
        &#125;

        @Override
        public Object[] toArray() &#123;
            return a.clone();
        &#125;

        @Override
        @SuppressWarnings(&quot;unchecked&quot;)
        public &lt;T&gt; T[] toArray(T[] a) &#123;
            int size = size();
            if (a.length &lt; size)
                return Arrays.copyOf(this.a, size,
                                     (Class&lt;? extends T[]&gt;) a.getClass());
            System.arraycopy(this.a, 0, a, 0, size);
            if (a.length &gt; size)
                a[size] = null;
            return a;
        &#125;

        @Override
        public E get(int index) &#123;
            return a[index];
        &#125;

        @Override
        public E set(int index, E element) &#123;
            E oldValue = a[index];
            a[index] = element;
            return oldValue;
        &#125;

        @Override
        public int indexOf(Object o) &#123;
            E[] a = this.a;
            if (o == null) &#123;
                for (int i = 0; i &lt; a.length; i++)
                    if (a[i] == null)
                        return i;
            &#125; else &#123;
                for (int i = 0; i &lt; a.length; i++)
                    if (o.equals(a[i]))
                        return i;
            &#125;
            return -1;
        &#125;

        @Override
        public boolean contains(Object o) &#123;
            return indexOf(o) != -1;
        &#125;

        @Override
        public Spliterator&lt;E&gt; spliterator() &#123;
            return Spliterators.spliterator(a, Spliterator.ORDERED);
        &#125;

        @Override
        public void forEach(Consumer&lt;? super E&gt; action) &#123;
            Objects.requireNonNull(action);
            for (E e : a) &#123;
                action.accept(e);
            &#125;
        &#125;

        @Override
        public void replaceAll(UnaryOperator&lt;E&gt; operator) &#123;
            Objects.requireNonNull(operator);
            E[] a = this.a;
            for (int i = 0; i &lt; a.length; i++) &#123;
                a[i] = operator.apply(a[i]);
            &#125;
        &#125;

        @Override
        public void sort(Comparator&lt;? super E&gt; c) &#123;
            Arrays.sort(a, c);
        &#125;
    &#125;

    /**
     * Returns a hash code based on the contents of the specified array.
     * For any two &lt;tt&gt;long&lt;/tt&gt; arrays &lt;tt&gt;a&lt;/tt&gt; and &lt;tt&gt;b&lt;/tt&gt;
     * such that &lt;tt&gt;Arrays.equals(a, b)&lt;/tt&gt;, it is also the case that
     * &lt;tt&gt;Arrays.hashCode(a) == Arrays.hashCode(b)&lt;/tt&gt;.
     *
     * &lt;p&gt;The value returned by this method is the same value that would be
     * obtained by invoking the &#123;@link List#hashCode() &lt;tt&gt;hashCode&lt;/tt&gt;&#125;
     * method on a &#123;@link List&#125; containing a sequence of &#123;@link Long&#125;
     * instances representing the elements of &lt;tt&gt;a&lt;/tt&gt; in the same order.
     * If &lt;tt&gt;a&lt;/tt&gt; is &lt;tt&gt;null&lt;/tt&gt;, this method returns 0.
     *
     * @param a the array whose hash value to compute
     * @return a content-based hash code for &lt;tt&gt;a&lt;/tt&gt;
     * @since 1.5
     */
    public static int hashCode(long a[]) &#123;
        if (a == null)
            return 0;

        int result = 1;
        for (long element : a) &#123;
            int elementHash = (int)(element ^ (element &gt;&gt;&gt; 32));
            result = 31 * result + elementHash;
        &#125;

        return result;
    &#125;

    /**
     * Returns a hash code based on the contents of the specified array.
     * For any two non-null &lt;tt&gt;int&lt;/tt&gt; arrays &lt;tt&gt;a&lt;/tt&gt; and &lt;tt&gt;b&lt;/tt&gt;
     * such that &lt;tt&gt;Arrays.equals(a, b)&lt;/tt&gt;, it is also the case that
     * &lt;tt&gt;Arrays.hashCode(a) == Arrays.hashCode(b)&lt;/tt&gt;.
     *
     * &lt;p&gt;The value returned by this method is the same value that would be
     * obtained by invoking the &#123;@link List#hashCode() &lt;tt&gt;hashCode&lt;/tt&gt;&#125;
     * method on a &#123;@link List&#125; containing a sequence of &#123;@link Integer&#125;
     * instances representing the elements of &lt;tt&gt;a&lt;/tt&gt; in the same order.
     * If &lt;tt&gt;a&lt;/tt&gt; is &lt;tt&gt;null&lt;/tt&gt;, this method returns 0.
     *
     * @param a the array whose hash value to compute
     * @return a content-based hash code for &lt;tt&gt;a&lt;/tt&gt;
     * @since 1.5
     */
    public static int hashCode(int a[]) &#123;
        if (a == null)
            return 0;

        int result = 1;
        for (int element : a)
            result = 31 * result + element;

        return result;
    &#125;

    /**
     * Returns a hash code based on the contents of the specified array.
     * For any two &lt;tt&gt;short&lt;/tt&gt; arrays &lt;tt&gt;a&lt;/tt&gt; and &lt;tt&gt;b&lt;/tt&gt;
     * such that &lt;tt&gt;Arrays.equals(a, b)&lt;/tt&gt;, it is also the case that
     * &lt;tt&gt;Arrays.hashCode(a) == Arrays.hashCode(b)&lt;/tt&gt;.
     *
     * &lt;p&gt;The value returned by this method is the same value that would be
     * obtained by invoking the &#123;@link List#hashCode() &lt;tt&gt;hashCode&lt;/tt&gt;&#125;
     * method on a &#123;@link List&#125; containing a sequence of &#123;@link Short&#125;
     * instances representing the elements of &lt;tt&gt;a&lt;/tt&gt; in the same order.
     * If &lt;tt&gt;a&lt;/tt&gt; is &lt;tt&gt;null&lt;/tt&gt;, this method returns 0.
     *
     * @param a the array whose hash value to compute
     * @return a content-based hash code for &lt;tt&gt;a&lt;/tt&gt;
     * @since 1.5
     */
    public static int hashCode(short a[]) &#123;
        if (a == null)
            return 0;

        int result = 1;
        for (short element : a)
            result = 31 * result + element;

        return result;
    &#125;

    /**
     * Returns a hash code based on the contents of the specified array.
     * For any two &lt;tt&gt;char&lt;/tt&gt; arrays &lt;tt&gt;a&lt;/tt&gt; and &lt;tt&gt;b&lt;/tt&gt;
     * such that &lt;tt&gt;Arrays.equals(a, b)&lt;/tt&gt;, it is also the case that
     * &lt;tt&gt;Arrays.hashCode(a) == Arrays.hashCode(b)&lt;/tt&gt;.
     *
     * &lt;p&gt;The value returned by this method is the same value that would be
     * obtained by invoking the &#123;@link List#hashCode() &lt;tt&gt;hashCode&lt;/tt&gt;&#125;
     * method on a &#123;@link List&#125; containing a sequence of &#123;@link Character&#125;
     * instances representing the elements of &lt;tt&gt;a&lt;/tt&gt; in the same order.
     * If &lt;tt&gt;a&lt;/tt&gt; is &lt;tt&gt;null&lt;/tt&gt;, this method returns 0.
     *
     * @param a the array whose hash value to compute
     * @return a content-based hash code for &lt;tt&gt;a&lt;/tt&gt;
     * @since 1.5
     */
    public static int hashCode(char a[]) &#123;
        if (a == null)
            return 0;

        int result = 1;
        for (char element : a)
            result = 31 * result + element;

        return result;
    &#125;

    /**
     * Returns a hash code based on the contents of the specified array.
     * For any two &lt;tt&gt;byte&lt;/tt&gt; arrays &lt;tt&gt;a&lt;/tt&gt; and &lt;tt&gt;b&lt;/tt&gt;
     * such that &lt;tt&gt;Arrays.equals(a, b)&lt;/tt&gt;, it is also the case that
     * &lt;tt&gt;Arrays.hashCode(a) == Arrays.hashCode(b)&lt;/tt&gt;.
     *
     * &lt;p&gt;The value returned by this method is the same value that would be
     * obtained by invoking the &#123;@link List#hashCode() &lt;tt&gt;hashCode&lt;/tt&gt;&#125;
     * method on a &#123;@link List&#125; containing a sequence of &#123;@link Byte&#125;
     * instances representing the elements of &lt;tt&gt;a&lt;/tt&gt; in the same order.
     * If &lt;tt&gt;a&lt;/tt&gt; is &lt;tt&gt;null&lt;/tt&gt;, this method returns 0.
     *
     * @param a the array whose hash value to compute
     * @return a content-based hash code for &lt;tt&gt;a&lt;/tt&gt;
     * @since 1.5
     */
    public static int hashCode(byte a[]) &#123;
        if (a == null)
            return 0;

        int result = 1;
        for (byte element : a)
            result = 31 * result + element;

        return result;
    &#125;

    /**
     * Returns a hash code based on the contents of the specified array.
     * For any two &lt;tt&gt;boolean&lt;/tt&gt; arrays &lt;tt&gt;a&lt;/tt&gt; and &lt;tt&gt;b&lt;/tt&gt;
     * such that &lt;tt&gt;Arrays.equals(a, b)&lt;/tt&gt;, it is also the case that
     * &lt;tt&gt;Arrays.hashCode(a) == Arrays.hashCode(b)&lt;/tt&gt;.
     *
     * &lt;p&gt;The value returned by this method is the same value that would be
     * obtained by invoking the &#123;@link List#hashCode() &lt;tt&gt;hashCode&lt;/tt&gt;&#125;
     * method on a &#123;@link List&#125; containing a sequence of &#123;@link Boolean&#125;
     * instances representing the elements of &lt;tt&gt;a&lt;/tt&gt; in the same order.
     * If &lt;tt&gt;a&lt;/tt&gt; is &lt;tt&gt;null&lt;/tt&gt;, this method returns 0.
     *
     * @param a the array whose hash value to compute
     * @return a content-based hash code for &lt;tt&gt;a&lt;/tt&gt;
     * @since 1.5
     */
    public static int hashCode(boolean a[]) &#123;
        if (a == null)
            return 0;

        int result = 1;
        for (boolean element : a)
            result = 31 * result + (element ? 1231 : 1237);

        return result;
    &#125;

    /**
     * Returns a hash code based on the contents of the specified array.
     * For any two &lt;tt&gt;float&lt;/tt&gt; arrays &lt;tt&gt;a&lt;/tt&gt; and &lt;tt&gt;b&lt;/tt&gt;
     * such that &lt;tt&gt;Arrays.equals(a, b)&lt;/tt&gt;, it is also the case that
     * &lt;tt&gt;Arrays.hashCode(a) == Arrays.hashCode(b)&lt;/tt&gt;.
     *
     * &lt;p&gt;The value returned by this method is the same value that would be
     * obtained by invoking the &#123;@link List#hashCode() &lt;tt&gt;hashCode&lt;/tt&gt;&#125;
     * method on a &#123;@link List&#125; containing a sequence of &#123;@link Float&#125;
     * instances representing the elements of &lt;tt&gt;a&lt;/tt&gt; in the same order.
     * If &lt;tt&gt;a&lt;/tt&gt; is &lt;tt&gt;null&lt;/tt&gt;, this method returns 0.
     *
     * @param a the array whose hash value to compute
     * @return a content-based hash code for &lt;tt&gt;a&lt;/tt&gt;
     * @since 1.5
     */
    public static int hashCode(float a[]) &#123;
        if (a == null)
            return 0;

        int result = 1;
        for (float element : a)
            result = 31 * result + Float.floatToIntBits(element);

        return result;
    &#125;

    /**
     * Returns a hash code based on the contents of the specified array.
     * For any two &lt;tt&gt;double&lt;/tt&gt; arrays &lt;tt&gt;a&lt;/tt&gt; and &lt;tt&gt;b&lt;/tt&gt;
     * such that &lt;tt&gt;Arrays.equals(a, b)&lt;/tt&gt;, it is also the case that
     * &lt;tt&gt;Arrays.hashCode(a) == Arrays.hashCode(b)&lt;/tt&gt;.
     *
     * &lt;p&gt;The value returned by this method is the same value that would be
     * obtained by invoking the &#123;@link List#hashCode() &lt;tt&gt;hashCode&lt;/tt&gt;&#125;
     * method on a &#123;@link List&#125; containing a sequence of &#123;@link Double&#125;
     * instances representing the elements of &lt;tt&gt;a&lt;/tt&gt; in the same order.
     * If &lt;tt&gt;a&lt;/tt&gt; is &lt;tt&gt;null&lt;/tt&gt;, this method returns 0.
     *
     * @param a the array whose hash value to compute
     * @return a content-based hash code for &lt;tt&gt;a&lt;/tt&gt;
     * @since 1.5
     */
    public static int hashCode(double a[]) &#123;
        if (a == null)
            return 0;

        int result = 1;
        for (double element : a) &#123;
            long bits = Double.doubleToLongBits(element);
            result = 31 * result + (int)(bits ^ (bits &gt;&gt;&gt; 32));
        &#125;
        return result;
    &#125;

    /**
     * Returns a hash code based on the contents of the specified array.  If
     * the array contains other arrays as elements, the hash code is based on
     * their identities rather than their contents.  It is therefore
     * acceptable to invoke this method on an array that contains itself as an
     * element,  either directly or indirectly through one or more levels of
     * arrays.
     *
     * &lt;p&gt;For any two arrays &lt;tt&gt;a&lt;/tt&gt; and &lt;tt&gt;b&lt;/tt&gt; such that
     * &lt;tt&gt;Arrays.equals(a, b)&lt;/tt&gt;, it is also the case that
     * &lt;tt&gt;Arrays.hashCode(a) == Arrays.hashCode(b)&lt;/tt&gt;.
     *
     * &lt;p&gt;The value returned by this method is equal to the value that would
     * be returned by &lt;tt&gt;Arrays.asList(a).hashCode()&lt;/tt&gt;, unless &lt;tt&gt;a&lt;/tt&gt;
     * is &lt;tt&gt;null&lt;/tt&gt;, in which case &lt;tt&gt;0&lt;/tt&gt; is returned.
     *
     * @param a the array whose content-based hash code to compute
     * @return a content-based hash code for &lt;tt&gt;a&lt;/tt&gt;
     * @see #deepHashCode(Object[])
     * @since 1.5
     */
    public static int hashCode(Object a[]) &#123;
        if (a == null)
            return 0;

        int result = 1;

        for (Object element : a)
            result = 31 * result + (element == null ? 0 : element.hashCode());

        return result;
    &#125;

    /**
     * Returns a hash code based on the &quot;deep contents&quot; of the specified
     * array.  If the array contains other arrays as elements, the
     * hash code is based on their contents and so on, ad infinitum.
     * It is therefore unacceptable to invoke this method on an array that
     * contains itself as an element, either directly or indirectly through
     * one or more levels of arrays.  The behavior of such an invocation is
     * undefined.
     *
     * &lt;p&gt;For any two arrays &lt;tt&gt;a&lt;/tt&gt; and &lt;tt&gt;b&lt;/tt&gt; such that
     * &lt;tt&gt;Arrays.deepEquals(a, b)&lt;/tt&gt;, it is also the case that
     * &lt;tt&gt;Arrays.deepHashCode(a) == Arrays.deepHashCode(b)&lt;/tt&gt;.
     *
     * &lt;p&gt;The computation of the value returned by this method is similar to
     * that of the value returned by &#123;@link List#hashCode()&#125; on a list
     * containing the same elements as &lt;tt&gt;a&lt;/tt&gt; in the same order, with one
     * difference: If an element &lt;tt&gt;e&lt;/tt&gt; of &lt;tt&gt;a&lt;/tt&gt; is itself an array,
     * its hash code is computed not by calling &lt;tt&gt;e.hashCode()&lt;/tt&gt;, but as
     * by calling the appropriate overloading of &lt;tt&gt;Arrays.hashCode(e)&lt;/tt&gt;
     * if &lt;tt&gt;e&lt;/tt&gt; is an array of a primitive type, or as by calling
     * &lt;tt&gt;Arrays.deepHashCode(e)&lt;/tt&gt; recursively if &lt;tt&gt;e&lt;/tt&gt; is an array
     * of a reference type.  If &lt;tt&gt;a&lt;/tt&gt; is &lt;tt&gt;null&lt;/tt&gt;, this method
     * returns 0.
     *
     * @param a the array whose deep-content-based hash code to compute
     * @return a deep-content-based hash code for &lt;tt&gt;a&lt;/tt&gt;
     * @see #hashCode(Object[])
     * @since 1.5
     */
    public static int deepHashCode(Object a[]) &#123;
        if (a == null)
            return 0;

        int result = 1;

        for (Object element : a) &#123;
            int elementHash = 0;
            if (element instanceof Object[])
                elementHash = deepHashCode((Object[]) element);
            else if (element instanceof byte[])
                elementHash = hashCode((byte[]) element);
            else if (element instanceof short[])
                elementHash = hashCode((short[]) element);
            else if (element instanceof int[])
                elementHash = hashCode((int[]) element);
            else if (element instanceof long[])
                elementHash = hashCode((long[]) element);
            else if (element instanceof char[])
                elementHash = hashCode((char[]) element);
            else if (element instanceof float[])
                elementHash = hashCode((float[]) element);
            else if (element instanceof double[])
                elementHash = hashCode((double[]) element);
            else if (element instanceof boolean[])
                elementHash = hashCode((boolean[]) element);
            else if (element != null)
                elementHash = element.hashCode();

            result = 31 * result + elementHash;
        &#125;

        return result;
    &#125;

    /**
     * Returns &lt;tt&gt;true&lt;/tt&gt; if the two specified arrays are &lt;i&gt;deeply
     * equal&lt;/i&gt; to one another.  Unlike the &#123;@link #equals(Object[],Object[])&#125;
     * method, this method is appropriate for use with nested arrays of
     * arbitrary depth.
     *
     * &lt;p&gt;Two array references are considered deeply equal if both
     * are &lt;tt&gt;null&lt;/tt&gt;, or if they refer to arrays that contain the same
     * number of elements and all corresponding pairs of elements in the two
     * arrays are deeply equal.
     *
     * &lt;p&gt;Two possibly &lt;tt&gt;null&lt;/tt&gt; elements &lt;tt&gt;e1&lt;/tt&gt; and &lt;tt&gt;e2&lt;/tt&gt; are
     * deeply equal if any of the following conditions hold:
     * &lt;ul&gt;
     *    &lt;li&gt; &lt;tt&gt;e1&lt;/tt&gt; and &lt;tt&gt;e2&lt;/tt&gt; are both arrays of object reference
     *         types, and &lt;tt&gt;Arrays.deepEquals(e1, e2) would return true&lt;/tt&gt;
     *    &lt;li&gt; &lt;tt&gt;e1&lt;/tt&gt; and &lt;tt&gt;e2&lt;/tt&gt; are arrays of the same primitive
     *         type, and the appropriate overloading of
     *         &lt;tt&gt;Arrays.equals(e1, e2)&lt;/tt&gt; would return true.
     *    &lt;li&gt; &lt;tt&gt;e1 == e2&lt;/tt&gt;
     *    &lt;li&gt; &lt;tt&gt;e1.equals(e2)&lt;/tt&gt; would return true.
     * &lt;/ul&gt;
     * Note that this definition permits &lt;tt&gt;null&lt;/tt&gt; elements at any depth.
     *
     * &lt;p&gt;If either of the specified arrays contain themselves as elements
     * either directly or indirectly through one or more levels of arrays,
     * the behavior of this method is undefined.
     *
     * @param a1 one array to be tested for equality
     * @param a2 the other array to be tested for equality
     * @return &lt;tt&gt;true&lt;/tt&gt; if the two arrays are equal
     * @see #equals(Object[],Object[])
     * @see Objects#deepEquals(Object, Object)
     * @since 1.5
     */
    public static boolean deepEquals(Object[] a1, Object[] a2) &#123;
        if (a1 == a2)
            return true;
        if (a1 == null || a2==null)
            return false;
        int length = a1.length;
        if (a2.length != length)
            return false;

        for (int i = 0; i &lt; length; i++) &#123;
            Object e1 = a1[i];
            Object e2 = a2[i];

            if (e1 == e2)
                continue;
            if (e1 == null)
                return false;

            // Figure out whether the two elements are equal
            boolean eq = deepEquals0(e1, e2);

            if (!eq)
                return false;
        &#125;
        return true;
    &#125;

    static boolean deepEquals0(Object e1, Object e2) &#123;
        assert e1 != null;
        boolean eq;
        if (e1 instanceof Object[] &amp;&amp; e2 instanceof Object[])
            eq = deepEquals ((Object[]) e1, (Object[]) e2);
        else if (e1 instanceof byte[] &amp;&amp; e2 instanceof byte[])
            eq = equals((byte[]) e1, (byte[]) e2);
        else if (e1 instanceof short[] &amp;&amp; e2 instanceof short[])
            eq = equals((short[]) e1, (short[]) e2);
        else if (e1 instanceof int[] &amp;&amp; e2 instanceof int[])
            eq = equals((int[]) e1, (int[]) e2);
        else if (e1 instanceof long[] &amp;&amp; e2 instanceof long[])
            eq = equals((long[]) e1, (long[]) e2);
        else if (e1 instanceof char[] &amp;&amp; e2 instanceof char[])
            eq = equals((char[]) e1, (char[]) e2);
        else if (e1 instanceof float[] &amp;&amp; e2 instanceof float[])
            eq = equals((float[]) e1, (float[]) e2);
        else if (e1 instanceof double[] &amp;&amp; e2 instanceof double[])
            eq = equals((double[]) e1, (double[]) e2);
        else if (e1 instanceof boolean[] &amp;&amp; e2 instanceof boolean[])
            eq = equals((boolean[]) e1, (boolean[]) e2);
        else
            eq = e1.equals(e2);
        return eq;
    &#125;

    /**
     * Returns a string representation of the contents of the specified array.
     * The string representation consists of a list of the array&#39;s elements,
     * enclosed in square brackets (&lt;tt&gt;&quot;[]&quot;&lt;/tt&gt;).  Adjacent elements are
     * separated by the characters &lt;tt&gt;&quot;, &quot;&lt;/tt&gt; (a comma followed by a
     * space).  Elements are converted to strings as by
     * &lt;tt&gt;String.valueOf(long)&lt;/tt&gt;.  Returns &lt;tt&gt;&quot;null&quot;&lt;/tt&gt; if &lt;tt&gt;a&lt;/tt&gt;
     * is &lt;tt&gt;null&lt;/tt&gt;.
     *
     * @param a the array whose string representation to return
     * @return a string representation of &lt;tt&gt;a&lt;/tt&gt;
     * @since 1.5
     */
    public static String toString(long[] a) &#123;
        if (a == null)
            return &quot;null&quot;;
        int iMax = a.length - 1;
        if (iMax == -1)
            return &quot;[]&quot;;

        StringBuilder b = new StringBuilder();
        b.append(&#39;[&#39;);
        for (int i = 0; ; i++) &#123;
            b.append(a[i]);
            if (i == iMax)
                return b.append(&#39;]&#39;).toString();
            b.append(&quot;, &quot;);
        &#125;
    &#125;

    /**
     * Returns a string representation of the contents of the specified array.
     * The string representation consists of a list of the array&#39;s elements,
     * enclosed in square brackets (&lt;tt&gt;&quot;[]&quot;&lt;/tt&gt;).  Adjacent elements are
     * separated by the characters &lt;tt&gt;&quot;, &quot;&lt;/tt&gt; (a comma followed by a
     * space).  Elements are converted to strings as by
     * &lt;tt&gt;String.valueOf(int)&lt;/tt&gt;.  Returns &lt;tt&gt;&quot;null&quot;&lt;/tt&gt; if &lt;tt&gt;a&lt;/tt&gt; is
     * &lt;tt&gt;null&lt;/tt&gt;.
     *
     * @param a the array whose string representation to return
     * @return a string representation of &lt;tt&gt;a&lt;/tt&gt;
     * @since 1.5
     */
    public static String toString(int[] a) &#123;
        if (a == null)
            return &quot;null&quot;;
        int iMax = a.length - 1;
        if (iMax == -1)
            return &quot;[]&quot;;

        StringBuilder b = new StringBuilder();
        b.append(&#39;[&#39;);
        for (int i = 0; ; i++) &#123;
            b.append(a[i]);
            if (i == iMax)
                return b.append(&#39;]&#39;).toString();
            b.append(&quot;, &quot;);
        &#125;
    &#125;

    /**
     * Returns a string representation of the contents of the specified array.
     * The string representation consists of a list of the array&#39;s elements,
     * enclosed in square brackets (&lt;tt&gt;&quot;[]&quot;&lt;/tt&gt;).  Adjacent elements are
     * separated by the characters &lt;tt&gt;&quot;, &quot;&lt;/tt&gt; (a comma followed by a
     * space).  Elements are converted to strings as by
     * &lt;tt&gt;String.valueOf(short)&lt;/tt&gt;.  Returns &lt;tt&gt;&quot;null&quot;&lt;/tt&gt; if &lt;tt&gt;a&lt;/tt&gt;
     * is &lt;tt&gt;null&lt;/tt&gt;.
     *
     * @param a the array whose string representation to return
     * @return a string representation of &lt;tt&gt;a&lt;/tt&gt;
     * @since 1.5
     */
    public static String toString(short[] a) &#123;
        if (a == null)
            return &quot;null&quot;;
        int iMax = a.length - 1;
        if (iMax == -1)
            return &quot;[]&quot;;

        StringBuilder b = new StringBuilder();
        b.append(&#39;[&#39;);
        for (int i = 0; ; i++) &#123;
            b.append(a[i]);
            if (i == iMax)
                return b.append(&#39;]&#39;).toString();
            b.append(&quot;, &quot;);
        &#125;
    &#125;

    /**
     * Returns a string representation of the contents of the specified array.
     * The string representation consists of a list of the array&#39;s elements,
     * enclosed in square brackets (&lt;tt&gt;&quot;[]&quot;&lt;/tt&gt;).  Adjacent elements are
     * separated by the characters &lt;tt&gt;&quot;, &quot;&lt;/tt&gt; (a comma followed by a
     * space).  Elements are converted to strings as by
     * &lt;tt&gt;String.valueOf(char)&lt;/tt&gt;.  Returns &lt;tt&gt;&quot;null&quot;&lt;/tt&gt; if &lt;tt&gt;a&lt;/tt&gt;
     * is &lt;tt&gt;null&lt;/tt&gt;.
     *
     * @param a the array whose string representation to return
     * @return a string representation of &lt;tt&gt;a&lt;/tt&gt;
     * @since 1.5
     */
    public static String toString(char[] a) &#123;
        if (a == null)
            return &quot;null&quot;;
        int iMax = a.length - 1;
        if (iMax == -1)
            return &quot;[]&quot;;

        StringBuilder b = new StringBuilder();
        b.append(&#39;[&#39;);
        for (int i = 0; ; i++) &#123;
            b.append(a[i]);
            if (i == iMax)
                return b.append(&#39;]&#39;).toString();
            b.append(&quot;, &quot;);
        &#125;
    &#125;

    /**
     * Returns a string representation of the contents of the specified array.
     * The string representation consists of a list of the array&#39;s elements,
     * enclosed in square brackets (&lt;tt&gt;&quot;[]&quot;&lt;/tt&gt;).  Adjacent elements
     * are separated by the characters &lt;tt&gt;&quot;, &quot;&lt;/tt&gt; (a comma followed
     * by a space).  Elements are converted to strings as by
     * &lt;tt&gt;String.valueOf(byte)&lt;/tt&gt;.  Returns &lt;tt&gt;&quot;null&quot;&lt;/tt&gt; if
     * &lt;tt&gt;a&lt;/tt&gt; is &lt;tt&gt;null&lt;/tt&gt;.
     *
     * @param a the array whose string representation to return
     * @return a string representation of &lt;tt&gt;a&lt;/tt&gt;
     * @since 1.5
     */
    public static String toString(byte[] a) &#123;
        if (a == null)
            return &quot;null&quot;;
        int iMax = a.length - 1;
        if (iMax == -1)
            return &quot;[]&quot;;

        StringBuilder b = new StringBuilder();
        b.append(&#39;[&#39;);
        for (int i = 0; ; i++) &#123;
            b.append(a[i]);
            if (i == iMax)
                return b.append(&#39;]&#39;).toString();
            b.append(&quot;, &quot;);
        &#125;
    &#125;

    /**
     * Returns a string representation of the contents of the specified array.
     * The string representation consists of a list of the array&#39;s elements,
     * enclosed in square brackets (&lt;tt&gt;&quot;[]&quot;&lt;/tt&gt;).  Adjacent elements are
     * separated by the characters &lt;tt&gt;&quot;, &quot;&lt;/tt&gt; (a comma followed by a
     * space).  Elements are converted to strings as by
     * &lt;tt&gt;String.valueOf(boolean)&lt;/tt&gt;.  Returns &lt;tt&gt;&quot;null&quot;&lt;/tt&gt; if
     * &lt;tt&gt;a&lt;/tt&gt; is &lt;tt&gt;null&lt;/tt&gt;.
     *
     * @param a the array whose string representation to return
     * @return a string representation of &lt;tt&gt;a&lt;/tt&gt;
     * @since 1.5
     */
    public static String toString(boolean[] a) &#123;
        if (a == null)
            return &quot;null&quot;;
        int iMax = a.length - 1;
        if (iMax == -1)
            return &quot;[]&quot;;

        StringBuilder b = new StringBuilder();
        b.append(&#39;[&#39;);
        for (int i = 0; ; i++) &#123;
            b.append(a[i]);
            if (i == iMax)
                return b.append(&#39;]&#39;).toString();
            b.append(&quot;, &quot;);
        &#125;
    &#125;

    /**
     * Returns a string representation of the contents of the specified array.
     * The string representation consists of a list of the array&#39;s elements,
     * enclosed in square brackets (&lt;tt&gt;&quot;[]&quot;&lt;/tt&gt;).  Adjacent elements are
     * separated by the characters &lt;tt&gt;&quot;, &quot;&lt;/tt&gt; (a comma followed by a
     * space).  Elements are converted to strings as by
     * &lt;tt&gt;String.valueOf(float)&lt;/tt&gt;.  Returns &lt;tt&gt;&quot;null&quot;&lt;/tt&gt; if &lt;tt&gt;a&lt;/tt&gt;
     * is &lt;tt&gt;null&lt;/tt&gt;.
     *
     * @param a the array whose string representation to return
     * @return a string representation of &lt;tt&gt;a&lt;/tt&gt;
     * @since 1.5
     */
    public static String toString(float[] a) &#123;
        if (a == null)
            return &quot;null&quot;;

        int iMax = a.length - 1;
        if (iMax == -1)
            return &quot;[]&quot;;

        StringBuilder b = new StringBuilder();
        b.append(&#39;[&#39;);
        for (int i = 0; ; i++) &#123;
            b.append(a[i]);
            if (i == iMax)
                return b.append(&#39;]&#39;).toString();
            b.append(&quot;, &quot;);
        &#125;
    &#125;

    /**
     * Returns a string representation of the contents of the specified array.
     * The string representation consists of a list of the array&#39;s elements,
     * enclosed in square brackets (&lt;tt&gt;&quot;[]&quot;&lt;/tt&gt;).  Adjacent elements are
     * separated by the characters &lt;tt&gt;&quot;, &quot;&lt;/tt&gt; (a comma followed by a
     * space).  Elements are converted to strings as by
     * &lt;tt&gt;String.valueOf(double)&lt;/tt&gt;.  Returns &lt;tt&gt;&quot;null&quot;&lt;/tt&gt; if &lt;tt&gt;a&lt;/tt&gt;
     * is &lt;tt&gt;null&lt;/tt&gt;.
     *
     * @param a the array whose string representation to return
     * @return a string representation of &lt;tt&gt;a&lt;/tt&gt;
     * @since 1.5
     */
    public static String toString(double[] a) &#123;
        if (a == null)
            return &quot;null&quot;;
        int iMax = a.length - 1;
        if (iMax == -1)
            return &quot;[]&quot;;

        StringBuilder b = new StringBuilder();
        b.append(&#39;[&#39;);
        for (int i = 0; ; i++) &#123;
            b.append(a[i]);
            if (i == iMax)
                return b.append(&#39;]&#39;).toString();
            b.append(&quot;, &quot;);
        &#125;
    &#125;

    /**
     * Returns a string representation of the contents of the specified array.
     * If the array contains other arrays as elements, they are converted to
     * strings by the &#123;@link Object#toString&#125; method inherited from
     * &lt;tt&gt;Object&lt;/tt&gt;, which describes their &lt;i&gt;identities&lt;/i&gt; rather than
     * their contents.
     *
     * &lt;p&gt;The value returned by this method is equal to the value that would
     * be returned by &lt;tt&gt;Arrays.asList(a).toString()&lt;/tt&gt;, unless &lt;tt&gt;a&lt;/tt&gt;
     * is &lt;tt&gt;null&lt;/tt&gt;, in which case &lt;tt&gt;&quot;null&quot;&lt;/tt&gt; is returned.
     *
     * @param a the array whose string representation to return
     * @return a string representation of &lt;tt&gt;a&lt;/tt&gt;
     * @see #deepToString(Object[])
     * @since 1.5
     */
    public static String toString(Object[] a) &#123;
        if (a == null)
            return &quot;null&quot;;

        int iMax = a.length - 1;
        if (iMax == -1)
            return &quot;[]&quot;;

        StringBuilder b = new StringBuilder();
        b.append(&#39;[&#39;);
        for (int i = 0; ; i++) &#123;
            b.append(String.valueOf(a[i]));
            if (i == iMax)
                return b.append(&#39;]&#39;).toString();
            b.append(&quot;, &quot;);
        &#125;
    &#125;

    /**
     * Returns a string representation of the &quot;deep contents&quot; of the specified
     * array.  If the array contains other arrays as elements, the string
     * representation contains their contents and so on.  This method is
     * designed for converting multidimensional arrays to strings.
     *
     * &lt;p&gt;The string representation consists of a list of the array&#39;s
     * elements, enclosed in square brackets (&lt;tt&gt;&quot;[]&quot;&lt;/tt&gt;).  Adjacent
     * elements are separated by the characters &lt;tt&gt;&quot;, &quot;&lt;/tt&gt; (a comma
     * followed by a space).  Elements are converted to strings as by
     * &lt;tt&gt;String.valueOf(Object)&lt;/tt&gt;, unless they are themselves
     * arrays.
     *
     * &lt;p&gt;If an element &lt;tt&gt;e&lt;/tt&gt; is an array of a primitive type, it is
     * converted to a string as by invoking the appropriate overloading of
     * &lt;tt&gt;Arrays.toString(e)&lt;/tt&gt;.  If an element &lt;tt&gt;e&lt;/tt&gt; is an array of a
     * reference type, it is converted to a string as by invoking
     * this method recursively.
     *
     * &lt;p&gt;To avoid infinite recursion, if the specified array contains itself
     * as an element, or contains an indirect reference to itself through one
     * or more levels of arrays, the self-reference is converted to the string
     * &lt;tt&gt;&quot;[...]&quot;&lt;/tt&gt;.  For example, an array containing only a reference
     * to itself would be rendered as &lt;tt&gt;&quot;[[...]]&quot;&lt;/tt&gt;.
     *
     * &lt;p&gt;This method returns &lt;tt&gt;&quot;null&quot;&lt;/tt&gt; if the specified array
     * is &lt;tt&gt;null&lt;/tt&gt;.
     *
     * @param a the array whose string representation to return
     * @return a string representation of &lt;tt&gt;a&lt;/tt&gt;
     * @see #toString(Object[])
     * @since 1.5
     */
    public static String deepToString(Object[] a) &#123;
        if (a == null)
            return &quot;null&quot;;

        int bufLen = 20 * a.length;
        if (a.length != 0 &amp;&amp; bufLen &lt;= 0)
            bufLen = Integer.MAX_VALUE;
        StringBuilder buf = new StringBuilder(bufLen);
        deepToString(a, buf, new HashSet&lt;Object[]&gt;());
        return buf.toString();
    &#125;

    private static void deepToString(Object[] a, StringBuilder buf,
                                     Set&lt;Object[]&gt; dejaVu) &#123;
        if (a == null) &#123;
            buf.append(&quot;null&quot;);
            return;
        &#125;
        int iMax = a.length - 1;
        if (iMax == -1) &#123;
            buf.append(&quot;[]&quot;);
            return;
        &#125;

        dejaVu.add(a);
        buf.append(&#39;[&#39;);
        for (int i = 0; ; i++) &#123;

            Object element = a[i];
            if (element == null) &#123;
                buf.append(&quot;null&quot;);
            &#125; else &#123;
                Class&lt;?&gt; eClass = element.getClass();

                if (eClass.isArray()) &#123;
                    if (eClass == byte[].class)
                        buf.append(toString((byte[]) element));
                    else if (eClass == short[].class)
                        buf.append(toString((short[]) element));
                    else if (eClass == int[].class)
                        buf.append(toString((int[]) element));
                    else if (eClass == long[].class)
                        buf.append(toString((long[]) element));
                    else if (eClass == char[].class)
                        buf.append(toString((char[]) element));
                    else if (eClass == float[].class)
                        buf.append(toString((float[]) element));
                    else if (eClass == double[].class)
                        buf.append(toString((double[]) element));
                    else if (eClass == boolean[].class)
                        buf.append(toString((boolean[]) element));
                    else &#123; // element is an array of object references
                        if (dejaVu.contains(element))
                            buf.append(&quot;[...]&quot;);
                        else
                            deepToString((Object[])element, buf, dejaVu);
                    &#125;
                &#125; else &#123;  // element is non-null and not an array
                    buf.append(element.toString());
                &#125;
            &#125;
            if (i == iMax)
                break;
            buf.append(&quot;, &quot;);
        &#125;
        buf.append(&#39;]&#39;);
        dejaVu.remove(a);
    &#125;


    /**
     * Set all elements of the specified array, using the provided
     * generator function to compute each element.
     *
     * &lt;p&gt;If the generator function throws an exception, it is relayed to
     * the caller and the array is left in an indeterminate state.
     *
     * @param &lt;T&gt; type of elements of the array
     * @param array array to be initialized
     * @param generator a function accepting an index and producing the desired
     *        value for that position
     * @throws NullPointerException if the generator is null
     * @since 1.8
     */
    public static &lt;T&gt; void setAll(T[] array, IntFunction&lt;? extends T&gt; generator) &#123;
        Objects.requireNonNull(generator);
        for (int i = 0; i &lt; array.length; i++)
            array[i] = generator.apply(i);
    &#125;

    /**
     * Set all elements of the specified array, in parallel, using the
     * provided generator function to compute each element.
     *
     * &lt;p&gt;If the generator function throws an exception, an unchecked exception
     * is thrown from &#123;@code parallelSetAll&#125; and the array is left in an
     * indeterminate state.
     *
     * @param &lt;T&gt; type of elements of the array
     * @param array array to be initialized
     * @param generator a function accepting an index and producing the desired
     *        value for that position
     * @throws NullPointerException if the generator is null
     * @since 1.8
     */
    public static &lt;T&gt; void parallelSetAll(T[] array, IntFunction&lt;? extends T&gt; generator) &#123;
        Objects.requireNonNull(generator);
        IntStream.range(0, array.length).parallel().forEach(i -&gt; &#123; array[i] = generator.apply(i); &#125;);
    &#125;

    /**
     * Set all elements of the specified array, using the provided
     * generator function to compute each element.
     *
     * &lt;p&gt;If the generator function throws an exception, it is relayed to
     * the caller and the array is left in an indeterminate state.
     *
     * @param array array to be initialized
     * @param generator a function accepting an index and producing the desired
     *        value for that position
     * @throws NullPointerException if the generator is null
     * @since 1.8
     */
    public static void setAll(int[] array, IntUnaryOperator generator) &#123;
        Objects.requireNonNull(generator);
        for (int i = 0; i &lt; array.length; i++)
            array[i] = generator.applyAsInt(i);
    &#125;

    /**
     * Set all elements of the specified array, in parallel, using the
     * provided generator function to compute each element.
     *
     * &lt;p&gt;If the generator function throws an exception, an unchecked exception
     * is thrown from &#123;@code parallelSetAll&#125; and the array is left in an
     * indeterminate state.
     *
     * @param array array to be initialized
     * @param generator a function accepting an index and producing the desired
     * value for that position
     * @throws NullPointerException if the generator is null
     * @since 1.8
     */
    public static void parallelSetAll(int[] array, IntUnaryOperator generator) &#123;
        Objects.requireNonNull(generator);
        IntStream.range(0, array.length).parallel().forEach(i -&gt; &#123; array[i] = generator.applyAsInt(i); &#125;);
    &#125;

    /**
     * Set all elements of the specified array, using the provided
     * generator function to compute each element.
     *
     * &lt;p&gt;If the generator function throws an exception, it is relayed to
     * the caller and the array is left in an indeterminate state.
     *
     * @param array array to be initialized
     * @param generator a function accepting an index and producing the desired
     *        value for that position
     * @throws NullPointerException if the generator is null
     * @since 1.8
     */
    public static void setAll(long[] array, IntToLongFunction generator) &#123;
        Objects.requireNonNull(generator);
        for (int i = 0; i &lt; array.length; i++)
            array[i] = generator.applyAsLong(i);
    &#125;

    /**
     * Set all elements of the specified array, in parallel, using the
     * provided generator function to compute each element.
     *
     * &lt;p&gt;If the generator function throws an exception, an unchecked exception
     * is thrown from &#123;@code parallelSetAll&#125; and the array is left in an
     * indeterminate state.
     *
     * @param array array to be initialized
     * @param generator a function accepting an index and producing the desired
     *        value for that position
     * @throws NullPointerException if the generator is null
     * @since 1.8
     */
    public static void parallelSetAll(long[] array, IntToLongFunction generator) &#123;
        Objects.requireNonNull(generator);
        IntStream.range(0, array.length).parallel().forEach(i -&gt; &#123; array[i] = generator.applyAsLong(i); &#125;);
    &#125;

    /**
     * Set all elements of the specified array, using the provided
     * generator function to compute each element.
     *
     * &lt;p&gt;If the generator function throws an exception, it is relayed to
     * the caller and the array is left in an indeterminate state.
     *
     * @param array array to be initialized
     * @param generator a function accepting an index and producing the desired
     *        value for that position
     * @throws NullPointerException if the generator is null
     * @since 1.8
     */
    public static void setAll(double[] array, IntToDoubleFunction generator) &#123;
        Objects.requireNonNull(generator);
        for (int i = 0; i &lt; array.length; i++)
            array[i] = generator.applyAsDouble(i);
    &#125;

    /**
     * Set all elements of the specified array, in parallel, using the
     * provided generator function to compute each element.
     *
     * &lt;p&gt;If the generator function throws an exception, an unchecked exception
     * is thrown from &#123;@code parallelSetAll&#125; and the array is left in an
     * indeterminate state.
     *
     * @param array array to be initialized
     * @param generator a function accepting an index and producing the desired
     *        value for that position
     * @throws NullPointerException if the generator is null
     * @since 1.8
     */
    public static void parallelSetAll(double[] array, IntToDoubleFunction generator) &#123;
        Objects.requireNonNull(generator);
        IntStream.range(0, array.length).parallel().forEach(i -&gt; &#123; array[i] = generator.applyAsDouble(i); &#125;);
    &#125;

    /**
     * Returns a &#123;@link Spliterator&#125; covering all of the specified array.
     *
     * &lt;p&gt;The spliterator reports &#123;@link Spliterator#SIZED&#125;,
     * &#123;@link Spliterator#SUBSIZED&#125;, &#123;@link Spliterator#ORDERED&#125;, and
     * &#123;@link Spliterator#IMMUTABLE&#125;.
     *
     * @param &lt;T&gt; type of elements
     * @param array the array, assumed to be unmodified during use
     * @return a spliterator for the array elements
     * @since 1.8
     */
    public static &lt;T&gt; Spliterator&lt;T&gt; spliterator(T[] array) &#123;
        return Spliterators.spliterator(array,
                                        Spliterator.ORDERED | Spliterator.IMMUTABLE);
    &#125;

    /**
     * Returns a &#123;@link Spliterator&#125; covering the specified range of the
     * specified array.
     *
     * &lt;p&gt;The spliterator reports &#123;@link Spliterator#SIZED&#125;,
     * &#123;@link Spliterator#SUBSIZED&#125;, &#123;@link Spliterator#ORDERED&#125;, and
     * &#123;@link Spliterator#IMMUTABLE&#125;.
     *
     * @param &lt;T&gt; type of elements
     * @param array the array, assumed to be unmodified during use
     * @param startInclusive the first index to cover, inclusive
     * @param endExclusive index immediately past the last index to cover
     * @return a spliterator for the array elements
     * @throws ArrayIndexOutOfBoundsException if &#123;@code startInclusive&#125; is
     *         negative, &#123;@code endExclusive&#125; is less than
     *         &#123;@code startInclusive&#125;, or &#123;@code endExclusive&#125; is greater than
     *         the array size
     * @since 1.8
     */
    public static &lt;T&gt; Spliterator&lt;T&gt; spliterator(T[] array, int startInclusive, int endExclusive) &#123;
        return Spliterators.spliterator(array, startInclusive, endExclusive,
                                        Spliterator.ORDERED | Spliterator.IMMUTABLE);
    &#125;

    /**
     * Returns a &#123;@link Spliterator.OfInt&#125; covering all of the specified array.
     *
     * &lt;p&gt;The spliterator reports &#123;@link Spliterator#SIZED&#125;,
     * &#123;@link Spliterator#SUBSIZED&#125;, &#123;@link Spliterator#ORDERED&#125;, and
     * &#123;@link Spliterator#IMMUTABLE&#125;.
     *
     * @param array the array, assumed to be unmodified during use
     * @return a spliterator for the array elements
     * @since 1.8
     */
    public static Spliterator.OfInt spliterator(int[] array) &#123;
        return Spliterators.spliterator(array,
                                        Spliterator.ORDERED | Spliterator.IMMUTABLE);
    &#125;

    /**
     * Returns a &#123;@link Spliterator.OfInt&#125; covering the specified range of the
     * specified array.
     *
     * &lt;p&gt;The spliterator reports &#123;@link Spliterator#SIZED&#125;,
     * &#123;@link Spliterator#SUBSIZED&#125;, &#123;@link Spliterator#ORDERED&#125;, and
     * &#123;@link Spliterator#IMMUTABLE&#125;.
     *
     * @param array the array, assumed to be unmodified during use
     * @param startInclusive the first index to cover, inclusive
     * @param endExclusive index immediately past the last index to cover
     * @return a spliterator for the array elements
     * @throws ArrayIndexOutOfBoundsException if &#123;@code startInclusive&#125; is
     *         negative, &#123;@code endExclusive&#125; is less than
     *         &#123;@code startInclusive&#125;, or &#123;@code endExclusive&#125; is greater than
     *         the array size
     * @since 1.8
     */
    public static Spliterator.OfInt spliterator(int[] array, int startInclusive, int endExclusive) &#123;
        return Spliterators.spliterator(array, startInclusive, endExclusive,
                                        Spliterator.ORDERED | Spliterator.IMMUTABLE);
    &#125;

    /**
     * Returns a &#123;@link Spliterator.OfLong&#125; covering all of the specified array.
     *
     * &lt;p&gt;The spliterator reports &#123;@link Spliterator#SIZED&#125;,
     * &#123;@link Spliterator#SUBSIZED&#125;, &#123;@link Spliterator#ORDERED&#125;, and
     * &#123;@link Spliterator#IMMUTABLE&#125;.
     *
     * @param array the array, assumed to be unmodified during use
     * @return the spliterator for the array elements
     * @since 1.8
     */
    public static Spliterator.OfLong spliterator(long[] array) &#123;
        return Spliterators.spliterator(array,
                                        Spliterator.ORDERED | Spliterator.IMMUTABLE);
    &#125;

    /**
     * Returns a &#123;@link Spliterator.OfLong&#125; covering the specified range of the
     * specified array.
     *
     * &lt;p&gt;The spliterator reports &#123;@link Spliterator#SIZED&#125;,
     * &#123;@link Spliterator#SUBSIZED&#125;, &#123;@link Spliterator#ORDERED&#125;, and
     * &#123;@link Spliterator#IMMUTABLE&#125;.
     *
     * @param array the array, assumed to be unmodified during use
     * @param startInclusive the first index to cover, inclusive
     * @param endExclusive index immediately past the last index to cover
     * @return a spliterator for the array elements
     * @throws ArrayIndexOutOfBoundsException if &#123;@code startInclusive&#125; is
     *         negative, &#123;@code endExclusive&#125; is less than
     *         &#123;@code startInclusive&#125;, or &#123;@code endExclusive&#125; is greater than
     *         the array size
     * @since 1.8
     */
    public static Spliterator.OfLong spliterator(long[] array, int startInclusive, int endExclusive) &#123;
        return Spliterators.spliterator(array, startInclusive, endExclusive,
                                        Spliterator.ORDERED | Spliterator.IMMUTABLE);
    &#125;

    /**
     * Returns a &#123;@link Spliterator.OfDouble&#125; covering all of the specified
     * array.
     *
     * &lt;p&gt;The spliterator reports &#123;@link Spliterator#SIZED&#125;,
     * &#123;@link Spliterator#SUBSIZED&#125;, &#123;@link Spliterator#ORDERED&#125;, and
     * &#123;@link Spliterator#IMMUTABLE&#125;.
     *
     * @param array the array, assumed to be unmodified during use
     * @return a spliterator for the array elements
     * @since 1.8
     */
    public static Spliterator.OfDouble spliterator(double[] array) &#123;
        return Spliterators.spliterator(array,
                                        Spliterator.ORDERED | Spliterator.IMMUTABLE);
    &#125;

    /**
     * Returns a &#123;@link Spliterator.OfDouble&#125; covering the specified range of
     * the specified array.
     *
     * &lt;p&gt;The spliterator reports &#123;@link Spliterator#SIZED&#125;,
     * &#123;@link Spliterator#SUBSIZED&#125;, &#123;@link Spliterator#ORDERED&#125;, and
     * &#123;@link Spliterator#IMMUTABLE&#125;.
     *
     * @param array the array, assumed to be unmodified during use
     * @param startInclusive the first index to cover, inclusive
     * @param endExclusive index immediately past the last index to cover
     * @return a spliterator for the array elements
     * @throws ArrayIndexOutOfBoundsException if &#123;@code startInclusive&#125; is
     *         negative, &#123;@code endExclusive&#125; is less than
     *         &#123;@code startInclusive&#125;, or &#123;@code endExclusive&#125; is greater than
     *         the array size
     * @since 1.8
     */
    public static Spliterator.OfDouble spliterator(double[] array, int startInclusive, int endExclusive) &#123;
        return Spliterators.spliterator(array, startInclusive, endExclusive,
                                        Spliterator.ORDERED | Spliterator.IMMUTABLE);
    &#125;

    /**
     * Returns a sequential &#123;@link Stream&#125; with the specified array as its
     * source.
     *
     * @param &lt;T&gt; The type of the array elements
     * @param array The array, assumed to be unmodified during use
     * @return a &#123;@code Stream&#125; for the array
     * @since 1.8
     */
    public static &lt;T&gt; Stream&lt;T&gt; stream(T[] array) &#123;
        return stream(array, 0, array.length);
    &#125;

    /**
     * Returns a sequential &#123;@link Stream&#125; with the specified range of the
     * specified array as its source.
     *
     * @param &lt;T&gt; the type of the array elements
     * @param array the array, assumed to be unmodified during use
     * @param startInclusive the first index to cover, inclusive
     * @param endExclusive index immediately past the last index to cover
     * @return a &#123;@code Stream&#125; for the array range
     * @throws ArrayIndexOutOfBoundsException if &#123;@code startInclusive&#125; is
     *         negative, &#123;@code endExclusive&#125; is less than
     *         &#123;@code startInclusive&#125;, or &#123;@code endExclusive&#125; is greater than
     *         the array size
     * @since 1.8
     */
    public static &lt;T&gt; Stream&lt;T&gt; stream(T[] array, int startInclusive, int endExclusive) &#123;
        return StreamSupport.stream(spliterator(array, startInclusive, endExclusive), false);
    &#125;

    /**
     * Returns a sequential &#123;@link IntStream&#125; with the specified array as its
     * source.
     *
     * @param array the array, assumed to be unmodified during use
     * @return an &#123;@code IntStream&#125; for the array
     * @since 1.8
     */
    public static IntStream stream(int[] array) &#123;
        return stream(array, 0, array.length);
    &#125;

    /**
     * Returns a sequential &#123;@link IntStream&#125; with the specified range of the
     * specified array as its source.
     *
     * @param array the array, assumed to be unmodified during use
     * @param startInclusive the first index to cover, inclusive
     * @param endExclusive index immediately past the last index to cover
     * @return an &#123;@code IntStream&#125; for the array range
     * @throws ArrayIndexOutOfBoundsException if &#123;@code startInclusive&#125; is
     *         negative, &#123;@code endExclusive&#125; is less than
     *         &#123;@code startInclusive&#125;, or &#123;@code endExclusive&#125; is greater than
     *         the array size
     * @since 1.8
     */
    public static IntStream stream(int[] array, int startInclusive, int endExclusive) &#123;
        return StreamSupport.intStream(spliterator(array, startInclusive, endExclusive), false);
    &#125;

    /**
     * Returns a sequential &#123;@link LongStream&#125; with the specified array as its
     * source.
     *
     * @param array the array, assumed to be unmodified during use
     * @return a &#123;@code LongStream&#125; for the array
     * @since 1.8
     */
    public static LongStream stream(long[] array) &#123;
        return stream(array, 0, array.length);
    &#125;

    /**
     * Returns a sequential &#123;@link LongStream&#125; with the specified range of the
     * specified array as its source.
     *
     * @param array the array, assumed to be unmodified during use
     * @param startInclusive the first index to cover, inclusive
     * @param endExclusive index immediately past the last index to cover
     * @return a &#123;@code LongStream&#125; for the array range
     * @throws ArrayIndexOutOfBoundsException if &#123;@code startInclusive&#125; is
     *         negative, &#123;@code endExclusive&#125; is less than
     *         &#123;@code startInclusive&#125;, or &#123;@code endExclusive&#125; is greater than
     *         the array size
     * @since 1.8
     */
    public static LongStream stream(long[] array, int startInclusive, int endExclusive) &#123;
        return StreamSupport.longStream(spliterator(array, startInclusive, endExclusive), false);
    &#125;

    /**
     * Returns a sequential &#123;@link DoubleStream&#125; with the specified array as its
     * source.
     *
     * @param array the array, assumed to be unmodified during use
     * @return a &#123;@code DoubleStream&#125; for the array
     * @since 1.8
     */
    public static DoubleStream stream(double[] array) &#123;
        return stream(array, 0, array.length);
    &#125;

    /**
     * Returns a sequential &#123;@link DoubleStream&#125; with the specified range of the
     * specified array as its source.
     *
     * @param array the array, assumed to be unmodified during use
     * @param startInclusive the first index to cover, inclusive
     * @param endExclusive index immediately past the last index to cover
     * @return a &#123;@code DoubleStream&#125; for the array range
     * @throws ArrayIndexOutOfBoundsException if &#123;@code startInclusive&#125; is
     *         negative, &#123;@code endExclusive&#125; is less than
     *         &#123;@code startInclusive&#125;, or &#123;@code endExclusive&#125; is greater than
     *         the array size
     * @since 1.8
     */
    public static DoubleStream stream(double[] array, int startInclusive, int endExclusive) &#123;
        return StreamSupport.doubleStream(spliterator(array, startInclusive, endExclusive), false);
    &#125;
&#125;
</code></pre>

      
       <hr><span style="font-style: italic;color: gray;"> 转载请注明来源，欢迎对文章中的引用来源进行考证，欢迎指出任何有错误或不够清晰的表达。可以在下面评论区评论，也可以邮件至 jaytp@qq.com </span>
    </div>
</article>







    




    </div>
    <div class="copyright">
        <p class="footer-entry">
    ©2016-2020 Yelog
</p>
<p class="footer-entry">Built with <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/yelog/hexo-theme-3-hexo" target="_blank">3-hexo</a> theme</p>

    </div>
    <div class="full-toc">
        <button class="full" data-title="切换全屏 快捷键 s"><span class="min "></span></button>
<a class="" id="rocket" ></a>

    </div>
</div>

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"rect":"opacity:0.7","log":false,"pluginJsPath":"lib/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
<script src="/js/jquery.pjax.js?v=1.1.0" ></script>

<script src="/js/script.js?v=1.1.0" ></script>
<script>
    var img_resize = 'default';
    function initArticle() {
        /*渲染对应的表格样式*/
        
            $("#post .pjax table").addClass("green_title");
        

        /*渲染打赏样式*/
        

        /*高亮代码块行号*/
        

        /*访问数量*/
        
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js");
        

        /*代码高亮，行号对齐*/
        $('.pre-numbering').css('line-height',$('.has-numbering').css('line-height'));

        
        
    }

    /*打赏页面隐藏与展示*/
    

</script>

<!--加入行号的高亮代码块样式-->

<!--自定义样式设置-->
<style>
    
    
    .nav {
        width: 542px;
    }
    .nav.fullscreen {
        margin-left: -542px;
    }
    .nav-left {
        width: 120px;
    }
    
    
    @media screen and (max-width: 1468px) {
        .nav {
            width: 492px;
        }
        .nav.fullscreen {
            margin-left: -492px;
        }
        .nav-left {
            width: 100px;
        }
    }
    
    
    @media screen and (max-width: 1024px) {
        .nav {
            width: 492px;
            margin-left: -492px
        }
        .nav.fullscreen {
            margin-left: 0;
        }
    }
    
    @media screen and (max-width: 426px) {
        .nav {
            width: 100%;
        }
        .nav-left {
            width: 100%;
        }
    }
    
    
    .nav-right .title-list nav a .post-title, .nav-right .title-list #local-search-result a .post-title {
        color: #383636;
    }
    
    
    .nav-right .title-list nav a .post-date, .nav-right .title-list #local-search-result a .post-date {
        color: #5e5e5f;
    }
    
    
    .nav-right nav a.hover, #local-search-result a.hover{
        background-color: #2e2f2f;
    }
    
    
    .nav-right nav a.hover > span{
        color: #ffffff !important;
    }
    

    /*列表样式*/
    

    /* 背景图样式 */
    
    #post {
        background: url(https://i.loli.net/2019/07/22/5d3521411f3f169375.png);
    }
    
    
    #post .index {
        background: url(https://i.loli.net/2019/07/22/5d3521411f3f169375.png);
    }
    


    /*引用块样式*/
    

    /*文章列表背景图*/
    
    .nav-right:before {
        content: ' ';
        display: block;
        position: absolute;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        opacity: 0.4;
        background: url("https://i.loli.net/2019/07/22/5d3521411f3f169375.png");
        background-repeat: no-repeat;
        background-position: 50% 0;
        -ms-background-size: cover;
        -o-background-size: cover;
        -moz-background-size: cover;
        -webkit-background-size: cover;
        background-size: cover;
    }
    

    
</style>







</html>
